// @ts-nocheck
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigDecimal: any;
  BigInt: any;
  Bytes: any;
  Int8: any;
  Timestamp: any;
};

export type Account = {
  /** Address linked to the account ID */
  address: Scalars['Bytes'];
  /** List of all the balances for each specific token the account has interacted with */
  balances: Array<AccountTokenBalance>;
  /** L2 transaction internalID where the account was first created and linked to an address. Useful for sorting and filtering purposes */
  createdAt: Scalars['BigDecimal'];
  /** L2 transaction where the account was first created and linked to an address */
  createdAtTransaction: Transaction;
  /** Internal ID used in the L2 transactions. Users will be of type User and have an ID > 10000. Pools will be of type Pool and have an id < 10000. ProtocolAccount is a special account with ID 0 which handles all token balances generated by protocol fees. */
  id: Scalars['ID'];
  /** Same as ID but expressed as a BigInt for sorting purposes */
  internalID: Scalars['BigInt'];
  /** L2 transaction internalID that last updated the account entity. Useful for sorting and filtering purposes */
  lastUpdatedAt: Scalars['BigDecimal'];
  /** L2 transaction that last updated the account entity */
  lastUpdatedAtTransaction: Transaction;
  /** L2 transactions that involved this account */
  transactions: Array<Transaction>;
};

export type AccountBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type AccountTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type AccountTokenBalance = {
  __typename?: 'AccountTokenBalance';
  /** Link to the Account entity. Can be a Pool or User entity */
  account: Account;
  balance: Scalars['BigInt'];
  dailyData: Array<AccountTokenBalanceDailyData>;
  /** ID is recreated following this pattern: <ACCOUNT ID>-<TOKEN ID>. Example: 10001-1 */
  id: Scalars['ID'];
  /** Link to the Token entity. Holds all details of the token itself. */
  token: Token;
  transactions: Array<Transaction>;
  weeklyData: Array<AccountTokenBalanceWeeklyData>;
};

export type AccountTokenBalanceDailyDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalanceDailyData_Filter>;
};

export type AccountTokenBalanceTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type AccountTokenBalanceWeeklyDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalanceWeeklyData_Filter>;
};

export type AccountTokenBalanceDailyData = {
  __typename?: 'AccountTokenBalanceDailyData';
  /** Link to the Account entity. Can be a Pool or User entity */
  account: Account;
  /** Link to the original AccountTokenBalance entity. */
  accountTokenBalance: AccountTokenBalance;
  /** Latest value for balance for this AccountTokenBalance entity on this specific day. Coincides with balanceClose */
  balance: Scalars['BigInt'];
  /** Last update of balance for this AccountTokenBalance entity on this specific day */
  balanceClose: Scalars['BigInt'];
  /** Highest balance for this AccountTokenBalance entity on this specific day */
  balanceHigh: Scalars['BigInt'];
  /** Lowest balance for this AccountTokenBalance entity on this specific day */
  balanceLow: Scalars['BigInt'];
  /** Balance for this AccountTokenBalance entity when it was created. */
  balanceOpen: Scalars['BigInt'];
  /** Timestamp of the end of the day. Timezone -> UTC */
  dayEnd: Scalars['BigInt'];
  /** Day number is the amount of days since the start block of Loopring 3.6 (block 11149814) */
  dayNumber: Scalars['Int'];
  /** Timestamp of the start of the day. Timezone -> UTC */
  dayStart: Scalars['BigInt'];
  /** The ID follows this pattern: <ACCOUNT TOKEN BALANCE ID>-<DAY NUMBER>. */
  id: Scalars['ID'];
  /** Link to the Token entity. Holds all details of the token itself. */
  token: Token;
};

export type AccountTokenBalanceDailyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountTokenBalance?: InputMaybe<Scalars['String']>;
  accountTokenBalance_?: InputMaybe<AccountTokenBalance_Filter>;
  accountTokenBalance_contains?: InputMaybe<Scalars['String']>;
  accountTokenBalance_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_gt?: InputMaybe<Scalars['String']>;
  accountTokenBalance_gte?: InputMaybe<Scalars['String']>;
  accountTokenBalance_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenBalance_lt?: InputMaybe<Scalars['String']>;
  accountTokenBalance_lte?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_contains?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenBalance_not_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  and?: InputMaybe<Array<InputMaybe<AccountTokenBalanceDailyData_Filter>>>;
  balance?: InputMaybe<Scalars['BigInt']>;
  balanceClose?: InputMaybe<Scalars['BigInt']>;
  balanceClose_gt?: InputMaybe<Scalars['BigInt']>;
  balanceClose_gte?: InputMaybe<Scalars['BigInt']>;
  balanceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceClose_lt?: InputMaybe<Scalars['BigInt']>;
  balanceClose_lte?: InputMaybe<Scalars['BigInt']>;
  balanceClose_not?: InputMaybe<Scalars['BigInt']>;
  balanceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceHigh?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_not?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceLow?: InputMaybe<Scalars['BigInt']>;
  balanceLow_gt?: InputMaybe<Scalars['BigInt']>;
  balanceLow_gte?: InputMaybe<Scalars['BigInt']>;
  balanceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceLow_lt?: InputMaybe<Scalars['BigInt']>;
  balanceLow_lte?: InputMaybe<Scalars['BigInt']>;
  balanceLow_not?: InputMaybe<Scalars['BigInt']>;
  balanceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceOpen?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_not?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_gt?: InputMaybe<Scalars['BigInt']>;
  balance_gte?: InputMaybe<Scalars['BigInt']>;
  balance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_lt?: InputMaybe<Scalars['BigInt']>;
  balance_lte?: InputMaybe<Scalars['BigInt']>;
  balance_not?: InputMaybe<Scalars['BigInt']>;
  balance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayEnd?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayEnd_lt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_lte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayNumber?: InputMaybe<Scalars['Int']>;
  dayNumber_gt?: InputMaybe<Scalars['Int']>;
  dayNumber_gte?: InputMaybe<Scalars['Int']>;
  dayNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  dayNumber_lt?: InputMaybe<Scalars['Int']>;
  dayNumber_lte?: InputMaybe<Scalars['Int']>;
  dayNumber_not?: InputMaybe<Scalars['Int']>;
  dayNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  dayStart?: InputMaybe<Scalars['BigInt']>;
  dayStart_gt?: InputMaybe<Scalars['BigInt']>;
  dayStart_gte?: InputMaybe<Scalars['BigInt']>;
  dayStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayStart_lt?: InputMaybe<Scalars['BigInt']>;
  dayStart_lte?: InputMaybe<Scalars['BigInt']>;
  dayStart_not?: InputMaybe<Scalars['BigInt']>;
  dayStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<AccountTokenBalanceDailyData_Filter>>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
};

export enum AccountTokenBalanceDailyData_OrderBy {
  Account = 'account',
  AccountTokenBalance = 'accountTokenBalance',
  AccountTokenBalanceBalance = 'accountTokenBalance__balance',
  AccountTokenBalanceId = 'accountTokenBalance__id',
  AccountAddress = 'account__address',
  AccountCreatedAt = 'account__createdAt',
  AccountId = 'account__id',
  AccountInternalId = 'account__internalID',
  AccountLastUpdatedAt = 'account__lastUpdatedAt',
  Balance = 'balance',
  BalanceClose = 'balanceClose',
  BalanceHigh = 'balanceHigh',
  BalanceLow = 'balanceLow',
  BalanceOpen = 'balanceOpen',
  DayEnd = 'dayEnd',
  DayNumber = 'dayNumber',
  DayStart = 'dayStart',
  Id = 'id',
  Token = 'token',
  TokenAddress = 'token__address',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenInternalId = 'token__internalID',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenTradedVolume = 'token__tradedVolume',
  TokenTradedVolumeOrderbook = 'token__tradedVolumeOrderbook',
  TokenTradedVolumeSwap = 'token__tradedVolumeSwap',
}

export type AccountTokenBalanceWeeklyData = {
  __typename?: 'AccountTokenBalanceWeeklyData';
  /** Link to the Account entity. Can be a Pool or User entity */
  account: Account;
  /** Link to the original AccountTokenBalance entity. */
  accountTokenBalance: AccountTokenBalance;
  /** Latest value for balance for this AccountTokenBalance entity on this specific week. Coincides with balanceClose */
  balance: Scalars['BigInt'];
  /** Last update of balance for this AccountTokenBalance entity on this specific week */
  balanceClose: Scalars['BigInt'];
  /** Highest balance for this AccountTokenBalance entity on this specific week */
  balanceHigh: Scalars['BigInt'];
  /** Lowest balance for this AccountTokenBalance entity on this specific week */
  balanceLow: Scalars['BigInt'];
  /** Balance for this AccountTokenBalance entity when it was created. */
  balanceOpen: Scalars['BigInt'];
  /** The ID follows this pattern: <ACCOUNT TOKEN BALANCE ID>-<WEEK NUMBER>. */
  id: Scalars['ID'];
  /** Link to the Token entity. Holds all details of the token itself. */
  token: Token;
  /** Timestamp of the end of the week. Timezone -> UTC */
  weekEnd: Scalars['BigInt'];
  /** Week number is the amount of weeks since the start block of Loopring 3.6 (block 11149814) */
  weekNumber: Scalars['Int'];
  /** Timestamp of the start of the week. Timezone -> UTC */
  weekStart: Scalars['BigInt'];
};

export type AccountTokenBalanceWeeklyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountTokenBalance?: InputMaybe<Scalars['String']>;
  accountTokenBalance_?: InputMaybe<AccountTokenBalance_Filter>;
  accountTokenBalance_contains?: InputMaybe<Scalars['String']>;
  accountTokenBalance_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_gt?: InputMaybe<Scalars['String']>;
  accountTokenBalance_gte?: InputMaybe<Scalars['String']>;
  accountTokenBalance_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenBalance_lt?: InputMaybe<Scalars['String']>;
  accountTokenBalance_lte?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_contains?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenBalance_not_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  and?: InputMaybe<Array<InputMaybe<AccountTokenBalanceWeeklyData_Filter>>>;
  balance?: InputMaybe<Scalars['BigInt']>;
  balanceClose?: InputMaybe<Scalars['BigInt']>;
  balanceClose_gt?: InputMaybe<Scalars['BigInt']>;
  balanceClose_gte?: InputMaybe<Scalars['BigInt']>;
  balanceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceClose_lt?: InputMaybe<Scalars['BigInt']>;
  balanceClose_lte?: InputMaybe<Scalars['BigInt']>;
  balanceClose_not?: InputMaybe<Scalars['BigInt']>;
  balanceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceHigh?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_not?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceLow?: InputMaybe<Scalars['BigInt']>;
  balanceLow_gt?: InputMaybe<Scalars['BigInt']>;
  balanceLow_gte?: InputMaybe<Scalars['BigInt']>;
  balanceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceLow_lt?: InputMaybe<Scalars['BigInt']>;
  balanceLow_lte?: InputMaybe<Scalars['BigInt']>;
  balanceLow_not?: InputMaybe<Scalars['BigInt']>;
  balanceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceOpen?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_not?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_gt?: InputMaybe<Scalars['BigInt']>;
  balance_gte?: InputMaybe<Scalars['BigInt']>;
  balance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_lt?: InputMaybe<Scalars['BigInt']>;
  balance_lte?: InputMaybe<Scalars['BigInt']>;
  balance_not?: InputMaybe<Scalars['BigInt']>;
  balance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<AccountTokenBalanceWeeklyData_Filter>>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  weekEnd?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekEnd_lt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_lte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekNumber?: InputMaybe<Scalars['Int']>;
  weekNumber_gt?: InputMaybe<Scalars['Int']>;
  weekNumber_gte?: InputMaybe<Scalars['Int']>;
  weekNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  weekNumber_lt?: InputMaybe<Scalars['Int']>;
  weekNumber_lte?: InputMaybe<Scalars['Int']>;
  weekNumber_not?: InputMaybe<Scalars['Int']>;
  weekNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  weekStart?: InputMaybe<Scalars['BigInt']>;
  weekStart_gt?: InputMaybe<Scalars['BigInt']>;
  weekStart_gte?: InputMaybe<Scalars['BigInt']>;
  weekStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekStart_lt?: InputMaybe<Scalars['BigInt']>;
  weekStart_lte?: InputMaybe<Scalars['BigInt']>;
  weekStart_not?: InputMaybe<Scalars['BigInt']>;
  weekStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum AccountTokenBalanceWeeklyData_OrderBy {
  Account = 'account',
  AccountTokenBalance = 'accountTokenBalance',
  AccountTokenBalanceBalance = 'accountTokenBalance__balance',
  AccountTokenBalanceId = 'accountTokenBalance__id',
  AccountAddress = 'account__address',
  AccountCreatedAt = 'account__createdAt',
  AccountId = 'account__id',
  AccountInternalId = 'account__internalID',
  AccountLastUpdatedAt = 'account__lastUpdatedAt',
  Balance = 'balance',
  BalanceClose = 'balanceClose',
  BalanceHigh = 'balanceHigh',
  BalanceLow = 'balanceLow',
  BalanceOpen = 'balanceOpen',
  Id = 'id',
  Token = 'token',
  TokenAddress = 'token__address',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenInternalId = 'token__internalID',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenTradedVolume = 'token__tradedVolume',
  TokenTradedVolumeOrderbook = 'token__tradedVolumeOrderbook',
  TokenTradedVolumeSwap = 'token__tradedVolumeSwap',
  WeekEnd = 'weekEnd',
  WeekNumber = 'weekNumber',
  WeekStart = 'weekStart',
}

export type AccountTokenBalance_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  and?: InputMaybe<Array<InputMaybe<AccountTokenBalance_Filter>>>;
  balance?: InputMaybe<Scalars['BigInt']>;
  balance_gt?: InputMaybe<Scalars['BigInt']>;
  balance_gte?: InputMaybe<Scalars['BigInt']>;
  balance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_lt?: InputMaybe<Scalars['BigInt']>;
  balance_lte?: InputMaybe<Scalars['BigInt']>;
  balance_not?: InputMaybe<Scalars['BigInt']>;
  balance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dailyData_?: InputMaybe<AccountTokenBalanceDailyData_Filter>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<AccountTokenBalance_Filter>>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  transactions_?: InputMaybe<Transaction_Filter>;
  weeklyData_?: InputMaybe<AccountTokenBalanceWeeklyData_Filter>;
};

export enum AccountTokenBalance_OrderBy {
  Account = 'account',
  AccountAddress = 'account__address',
  AccountCreatedAt = 'account__createdAt',
  AccountId = 'account__id',
  AccountInternalId = 'account__internalID',
  AccountLastUpdatedAt = 'account__lastUpdatedAt',
  Balance = 'balance',
  DailyData = 'dailyData',
  Id = 'id',
  Token = 'token',
  TokenAddress = 'token__address',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenInternalId = 'token__internalID',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenTradedVolume = 'token__tradedVolume',
  TokenTradedVolumeOrderbook = 'token__tradedVolumeOrderbook',
  TokenTradedVolumeSwap = 'token__tradedVolumeSwap',
  Transactions = 'transactions',
  WeeklyData = 'weeklyData',
}

export type AccountUpdate = Transaction & {
  __typename?: 'AccountUpdate';
  /** [RAW L2 DATA] Account ID of the user account updated */
  accountID: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Fee amount paid */
  fee: Scalars['BigInt'];
  /** Token entity with information about the token used to pay the operator fees */
  feeToken: Token;
  /** [RAW L2 DATA] Token ID of token used to pay the operator fees */
  feeTokenID: Scalars['Int'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] Nonce */
  nonce: Scalars['Int'];
  /** [RAW L2 DATA] Address of the user account updated */
  owner: Scalars['String'];
  /** [RAW L2 DATA] Updated public key for the account */
  publicKey: Scalars['String'];
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
  /** [RAW L2 DATA] Update type */
  updateType: Scalars['Int'];
  /** User account entity updated in this transaction */
  user: User;
};

export type AccountUpdateAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type AccountUpdateTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type AccountUpdate_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountID?: InputMaybe<Scalars['Int']>;
  accountID_gt?: InputMaybe<Scalars['Int']>;
  accountID_gte?: InputMaybe<Scalars['Int']>;
  accountID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountID_lt?: InputMaybe<Scalars['Int']>;
  accountID_lte?: InputMaybe<Scalars['Int']>;
  accountID_not?: InputMaybe<Scalars['Int']>;
  accountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  and?: InputMaybe<Array<InputMaybe<AccountUpdate_Filter>>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  nonce?: InputMaybe<Scalars['Int']>;
  nonce_gt?: InputMaybe<Scalars['Int']>;
  nonce_gte?: InputMaybe<Scalars['Int']>;
  nonce_in?: InputMaybe<Array<Scalars['Int']>>;
  nonce_lt?: InputMaybe<Scalars['Int']>;
  nonce_lte?: InputMaybe<Scalars['Int']>;
  nonce_not?: InputMaybe<Scalars['Int']>;
  nonce_not_in?: InputMaybe<Array<Scalars['Int']>>;
  or?: InputMaybe<Array<InputMaybe<AccountUpdate_Filter>>>;
  owner?: InputMaybe<Scalars['String']>;
  owner_contains?: InputMaybe<Scalars['String']>;
  owner_contains_nocase?: InputMaybe<Scalars['String']>;
  owner_ends_with?: InputMaybe<Scalars['String']>;
  owner_ends_with_nocase?: InputMaybe<Scalars['String']>;
  owner_gt?: InputMaybe<Scalars['String']>;
  owner_gte?: InputMaybe<Scalars['String']>;
  owner_in?: InputMaybe<Array<Scalars['String']>>;
  owner_lt?: InputMaybe<Scalars['String']>;
  owner_lte?: InputMaybe<Scalars['String']>;
  owner_not?: InputMaybe<Scalars['String']>;
  owner_not_contains?: InputMaybe<Scalars['String']>;
  owner_not_contains_nocase?: InputMaybe<Scalars['String']>;
  owner_not_ends_with?: InputMaybe<Scalars['String']>;
  owner_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  owner_not_in?: InputMaybe<Array<Scalars['String']>>;
  owner_not_starts_with?: InputMaybe<Scalars['String']>;
  owner_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  owner_starts_with?: InputMaybe<Scalars['String']>;
  owner_starts_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey?: InputMaybe<Scalars['String']>;
  publicKey_contains?: InputMaybe<Scalars['String']>;
  publicKey_contains_nocase?: InputMaybe<Scalars['String']>;
  publicKey_ends_with?: InputMaybe<Scalars['String']>;
  publicKey_ends_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_gt?: InputMaybe<Scalars['String']>;
  publicKey_gte?: InputMaybe<Scalars['String']>;
  publicKey_in?: InputMaybe<Array<Scalars['String']>>;
  publicKey_lt?: InputMaybe<Scalars['String']>;
  publicKey_lte?: InputMaybe<Scalars['String']>;
  publicKey_not?: InputMaybe<Scalars['String']>;
  publicKey_not_contains?: InputMaybe<Scalars['String']>;
  publicKey_not_contains_nocase?: InputMaybe<Scalars['String']>;
  publicKey_not_ends_with?: InputMaybe<Scalars['String']>;
  publicKey_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_not_in?: InputMaybe<Array<Scalars['String']>>;
  publicKey_not_starts_with?: InputMaybe<Scalars['String']>;
  publicKey_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_starts_with?: InputMaybe<Scalars['String']>;
  publicKey_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
  updateType?: InputMaybe<Scalars['Int']>;
  updateType_gt?: InputMaybe<Scalars['Int']>;
  updateType_gte?: InputMaybe<Scalars['Int']>;
  updateType_in?: InputMaybe<Array<Scalars['Int']>>;
  updateType_lt?: InputMaybe<Scalars['Int']>;
  updateType_lte?: InputMaybe<Scalars['Int']>;
  updateType_not?: InputMaybe<Scalars['Int']>;
  updateType_not_in?: InputMaybe<Array<Scalars['Int']>>;
  user?: InputMaybe<Scalars['String']>;
  user_?: InputMaybe<User_Filter>;
  user_contains?: InputMaybe<Scalars['String']>;
  user_contains_nocase?: InputMaybe<Scalars['String']>;
  user_ends_with?: InputMaybe<Scalars['String']>;
  user_ends_with_nocase?: InputMaybe<Scalars['String']>;
  user_gt?: InputMaybe<Scalars['String']>;
  user_gte?: InputMaybe<Scalars['String']>;
  user_in?: InputMaybe<Array<Scalars['String']>>;
  user_lt?: InputMaybe<Scalars['String']>;
  user_lte?: InputMaybe<Scalars['String']>;
  user_not?: InputMaybe<Scalars['String']>;
  user_not_contains?: InputMaybe<Scalars['String']>;
  user_not_contains_nocase?: InputMaybe<Scalars['String']>;
  user_not_ends_with?: InputMaybe<Scalars['String']>;
  user_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  user_not_in?: InputMaybe<Array<Scalars['String']>>;
  user_not_starts_with?: InputMaybe<Scalars['String']>;
  user_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  user_starts_with?: InputMaybe<Scalars['String']>;
  user_starts_with_nocase?: InputMaybe<Scalars['String']>;
};

export enum AccountUpdate_OrderBy {
  AccountId = 'accountID',
  Accounts = 'accounts',
  Block = 'block',
  BlockAccountUpdateCount = 'block__accountUpdateCount',
  BlockAccountUpdateSize = 'block__accountUpdateSize',
  BlockAddCount = 'block__addCount',
  BlockAuxiliaryData = 'block__auxiliaryData',
  BlockBlockHash = 'block__blockHash',
  BlockBlockSize = 'block__blockSize',
  BlockBlockType = 'block__blockType',
  BlockBlockVersion = 'block__blockVersion',
  BlockData = 'block__data',
  BlockDepositCount = 'block__depositCount',
  BlockDepositSize = 'block__depositSize',
  BlockExchange = 'block__exchange',
  BlockGasLimit = 'block__gasLimit',
  BlockGasPrice = 'block__gasPrice',
  BlockHeight = 'block__height',
  BlockId = 'block__id',
  BlockInternalId = 'block__internalID',
  BlockNumConditionalTransactions = 'block__numConditionalTransactions',
  BlockOffchainData = 'block__offchainData',
  BlockOperatorAccountId = 'block__operatorAccountID',
  BlockOrderbookTradeCount = 'block__orderbookTradeCount',
  BlockProtocolFeeBips = 'block__protocolFeeBips',
  BlockRemoveCount = 'block__removeCount',
  BlockSignatureVerificationCount = 'block__signatureVerificationCount',
  BlockStoreBlockInfoOnchain = 'block__storeBlockInfoOnchain',
  BlockSwapCount = 'block__swapCount',
  BlockTimestamp = 'block__timestamp',
  BlockTransactionCount = 'block__transactionCount',
  BlockTransferCount = 'block__transferCount',
  BlockTxHash = 'block__txHash',
  BlockWithdrawSize = 'block__withdrawSize',
  BlockWithdrawalCount = 'block__withdrawalCount',
  Data = 'data',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  FeeTokenAddress = 'feeToken__address',
  FeeTokenDecimals = 'feeToken__decimals',
  FeeTokenId = 'feeToken__id',
  FeeTokenInternalId = 'feeToken__internalID',
  FeeTokenName = 'feeToken__name',
  FeeTokenSymbol = 'feeToken__symbol',
  FeeTokenTradedVolume = 'feeToken__tradedVolume',
  FeeTokenTradedVolumeOrderbook = 'feeToken__tradedVolumeOrderbook',
  FeeTokenTradedVolumeSwap = 'feeToken__tradedVolumeSwap',
  Id = 'id',
  InternalId = 'internalID',
  Nonce = 'nonce',
  Owner = 'owner',
  PublicKey = 'publicKey',
  TokenBalances = 'tokenBalances',
  Typename = 'typename',
  UpdateType = 'updateType',
  User = 'user',
  UserAddress = 'user__address',
  UserCreatedAt = 'user__createdAt',
  UserId = 'user__id',
  UserInternalId = 'user__internalID',
  UserLastUpdatedAt = 'user__lastUpdatedAt',
  UserPublicKey = 'user__publicKey',
}

export type Account_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  address?: InputMaybe<Scalars['Bytes']>;
  address_contains?: InputMaybe<Scalars['Bytes']>;
  address_gt?: InputMaybe<Scalars['Bytes']>;
  address_gte?: InputMaybe<Scalars['Bytes']>;
  address_in?: InputMaybe<Array<Scalars['Bytes']>>;
  address_lt?: InputMaybe<Scalars['Bytes']>;
  address_lte?: InputMaybe<Scalars['Bytes']>;
  address_not?: InputMaybe<Scalars['Bytes']>;
  address_not_contains?: InputMaybe<Scalars['Bytes']>;
  address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<Account_Filter>>>;
  balances_?: InputMaybe<AccountTokenBalance_Filter>;
  createdAt?: InputMaybe<Scalars['BigDecimal']>;
  createdAtTransaction?: InputMaybe<Scalars['String']>;
  createdAtTransaction_?: InputMaybe<Transaction_Filter>;
  createdAtTransaction_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_lt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_lte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  createdAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  lastUpdatedAt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAtTransaction?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_?: InputMaybe<Transaction_Filter>;
  lastUpdatedAtTransaction_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_lt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_lte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  lastUpdatedAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  or?: InputMaybe<Array<InputMaybe<Account_Filter>>>;
  transactions_?: InputMaybe<Transaction_Filter>;
};

export enum Account_OrderBy {
  Address = 'address',
  Balances = 'balances',
  CreatedAt = 'createdAt',
  CreatedAtTransaction = 'createdAtTransaction',
  CreatedAtTransactionData = 'createdAtTransaction__data',
  CreatedAtTransactionId = 'createdAtTransaction__id',
  CreatedAtTransactionInternalId = 'createdAtTransaction__internalID',
  CreatedAtTransactionTypename = 'createdAtTransaction__typename',
  Id = 'id',
  InternalId = 'internalID',
  LastUpdatedAt = 'lastUpdatedAt',
  LastUpdatedAtTransaction = 'lastUpdatedAtTransaction',
  LastUpdatedAtTransactionData = 'lastUpdatedAtTransaction__data',
  LastUpdatedAtTransactionId = 'lastUpdatedAtTransaction__id',
  LastUpdatedAtTransactionInternalId = 'lastUpdatedAtTransaction__internalID',
  LastUpdatedAtTransactionTypename = 'lastUpdatedAtTransaction__typename',
  Transactions = 'transactions',
}

export enum Aggregation_Interval {
  Day = 'day',
  Hour = 'hour',
}

export type BatchSpotTrade = Transaction & {
  __typename?: 'BatchSpotTrade';
  /** Account entity A */
  accountA: Account;
  accountAFirstTokenAmountExchange: Scalars['BigInt'];
  accountASecondTokenAmountExchange: Scalars['BigInt'];
  accountAThirdTokenAmountExchange: Scalars['BigInt'];
  /** Account entity B */
  accountB: Account;
  accountBFirstToken?: Maybe<Token>;
  accountBFirstTokenAmountExchange: Scalars['BigInt'];
  accountBFirstTokenID?: Maybe<Scalars['Int']>;
  accountBSecondToken?: Maybe<Token>;
  accountBSecondTokenAmountExchange: Scalars['BigInt'];
  accountBSecondTokenID?: Maybe<Scalars['Int']>;
  /** Account entity C */
  accountC?: Maybe<Account>;
  accountCFirstToken?: Maybe<Token>;
  accountCFirstTokenAmountExchange: Scalars['BigInt'];
  accountCFirstTokenID?: Maybe<Scalars['Int']>;
  accountCSecondToken?: Maybe<Token>;
  accountCSecondTokenAmountExchange: Scalars['BigInt'];
  accountCSecondTokenID?: Maybe<Scalars['Int']>;
  /** Account entity D */
  accountD?: Maybe<Account>;
  accountDFirstToken?: Maybe<Token>;
  accountDFirstTokenAmountExchange: Scalars['BigInt'];
  accountDFirstTokenID?: Maybe<Scalars['Int']>;
  accountDSecondToken?: Maybe<Token>;
  accountDSecondTokenAmountExchange: Scalars['BigInt'];
  accountDSecondTokenID?: Maybe<Scalars['Int']>;
  /** Account entity E */
  accountE?: Maybe<Account>;
  accountEFirstToken?: Maybe<Token>;
  accountEFirstTokenAmountExchange: Scalars['BigInt'];
  accountEFirstTokenID?: Maybe<Scalars['Int']>;
  accountESecondToken?: Maybe<Token>;
  accountESecondTokenAmountExchange: Scalars['BigInt'];
  accountESecondTokenID?: Maybe<Scalars['Int']>;
  accountF?: Maybe<Account>;
  accountFFirstToken?: Maybe<Token>;
  accountFFirstTokenAmountExchange: Scalars['BigInt'];
  accountFFirstTokenID?: Maybe<Scalars['Int']>;
  accountFSecondToken?: Maybe<Token>;
  accountFSecondTokenAmountExchange: Scalars['BigInt'];
  accountFSecondTokenID?: Maybe<Scalars['Int']>;
  /** [RAW L2 DATA] Account ID of account A */
  accountIDA: Scalars['Int'];
  /** [RAW L2 DATA] Account ID of account B */
  accountIDB?: Maybe<Scalars['Int']>;
  /** [RAW L2 DATA] Account ID of account C */
  accountIDC?: Maybe<Scalars['Int']>;
  /** [RAW L2 DATA] Account ID of account D */
  accountIDD?: Maybe<Scalars['Int']>;
  /** [RAW L2 DATA] Account ID of account E */
  accountIDE?: Maybe<Scalars['Int']>;
  /** [RAW L2 DATA] Account ID of account F */
  accountIDF?: Maybe<Scalars['Int']>;
  accounts?: Maybe<Array<Account>>;
  /** BindToken */
  bindToken: Token;
  bindTokenID: Scalars['Int'];
  block: Block;
  data: Scalars['String'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** Token A */
  tokenA: Token;
  tokenAID: Scalars['Int'];
  /** Token B */
  tokenB: Token;
  tokenBID: Scalars['Int'];
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type BatchSpotTradeAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type BatchSpotTradeTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type BatchSpotTrade_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountA?: InputMaybe<Scalars['String']>;
  accountAFirstTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountAFirstTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountAFirstTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountAFirstTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountAFirstTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountAFirstTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountAFirstTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountAFirstTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountASecondTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountASecondTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountASecondTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountASecondTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountASecondTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountASecondTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountASecondTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountASecondTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountAThirdTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountAThirdTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountAThirdTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountAThirdTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountAThirdTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountAThirdTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountAThirdTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountAThirdTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountA_?: InputMaybe<Account_Filter>;
  accountA_contains?: InputMaybe<Scalars['String']>;
  accountA_contains_nocase?: InputMaybe<Scalars['String']>;
  accountA_ends_with?: InputMaybe<Scalars['String']>;
  accountA_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_gt?: InputMaybe<Scalars['String']>;
  accountA_gte?: InputMaybe<Scalars['String']>;
  accountA_in?: InputMaybe<Array<Scalars['String']>>;
  accountA_lt?: InputMaybe<Scalars['String']>;
  accountA_lte?: InputMaybe<Scalars['String']>;
  accountA_not?: InputMaybe<Scalars['String']>;
  accountA_not_contains?: InputMaybe<Scalars['String']>;
  accountA_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountA_not_ends_with?: InputMaybe<Scalars['String']>;
  accountA_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountA_not_starts_with?: InputMaybe<Scalars['String']>;
  accountA_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_starts_with?: InputMaybe<Scalars['String']>;
  accountA_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountB?: InputMaybe<Scalars['String']>;
  accountBFirstToken?: InputMaybe<Scalars['String']>;
  accountBFirstTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountBFirstTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountBFirstTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountBFirstTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountBFirstTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountBFirstTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountBFirstTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountBFirstTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountBFirstTokenID?: InputMaybe<Scalars['Int']>;
  accountBFirstTokenID_gt?: InputMaybe<Scalars['Int']>;
  accountBFirstTokenID_gte?: InputMaybe<Scalars['Int']>;
  accountBFirstTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountBFirstTokenID_lt?: InputMaybe<Scalars['Int']>;
  accountBFirstTokenID_lte?: InputMaybe<Scalars['Int']>;
  accountBFirstTokenID_not?: InputMaybe<Scalars['Int']>;
  accountBFirstTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountBFirstToken_?: InputMaybe<Token_Filter>;
  accountBFirstToken_contains?: InputMaybe<Scalars['String']>;
  accountBFirstToken_contains_nocase?: InputMaybe<Scalars['String']>;
  accountBFirstToken_ends_with?: InputMaybe<Scalars['String']>;
  accountBFirstToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountBFirstToken_gt?: InputMaybe<Scalars['String']>;
  accountBFirstToken_gte?: InputMaybe<Scalars['String']>;
  accountBFirstToken_in?: InputMaybe<Array<Scalars['String']>>;
  accountBFirstToken_lt?: InputMaybe<Scalars['String']>;
  accountBFirstToken_lte?: InputMaybe<Scalars['String']>;
  accountBFirstToken_not?: InputMaybe<Scalars['String']>;
  accountBFirstToken_not_contains?: InputMaybe<Scalars['String']>;
  accountBFirstToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountBFirstToken_not_ends_with?: InputMaybe<Scalars['String']>;
  accountBFirstToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountBFirstToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountBFirstToken_not_starts_with?: InputMaybe<Scalars['String']>;
  accountBFirstToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountBFirstToken_starts_with?: InputMaybe<Scalars['String']>;
  accountBFirstToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountBSecondToken?: InputMaybe<Scalars['String']>;
  accountBSecondTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountBSecondTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountBSecondTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountBSecondTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountBSecondTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountBSecondTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountBSecondTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountBSecondTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountBSecondTokenID?: InputMaybe<Scalars['Int']>;
  accountBSecondTokenID_gt?: InputMaybe<Scalars['Int']>;
  accountBSecondTokenID_gte?: InputMaybe<Scalars['Int']>;
  accountBSecondTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountBSecondTokenID_lt?: InputMaybe<Scalars['Int']>;
  accountBSecondTokenID_lte?: InputMaybe<Scalars['Int']>;
  accountBSecondTokenID_not?: InputMaybe<Scalars['Int']>;
  accountBSecondTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountBSecondToken_?: InputMaybe<Token_Filter>;
  accountBSecondToken_contains?: InputMaybe<Scalars['String']>;
  accountBSecondToken_contains_nocase?: InputMaybe<Scalars['String']>;
  accountBSecondToken_ends_with?: InputMaybe<Scalars['String']>;
  accountBSecondToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountBSecondToken_gt?: InputMaybe<Scalars['String']>;
  accountBSecondToken_gte?: InputMaybe<Scalars['String']>;
  accountBSecondToken_in?: InputMaybe<Array<Scalars['String']>>;
  accountBSecondToken_lt?: InputMaybe<Scalars['String']>;
  accountBSecondToken_lte?: InputMaybe<Scalars['String']>;
  accountBSecondToken_not?: InputMaybe<Scalars['String']>;
  accountBSecondToken_not_contains?: InputMaybe<Scalars['String']>;
  accountBSecondToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountBSecondToken_not_ends_with?: InputMaybe<Scalars['String']>;
  accountBSecondToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountBSecondToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountBSecondToken_not_starts_with?: InputMaybe<Scalars['String']>;
  accountBSecondToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountBSecondToken_starts_with?: InputMaybe<Scalars['String']>;
  accountBSecondToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_?: InputMaybe<Account_Filter>;
  accountB_contains?: InputMaybe<Scalars['String']>;
  accountB_contains_nocase?: InputMaybe<Scalars['String']>;
  accountB_ends_with?: InputMaybe<Scalars['String']>;
  accountB_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_gt?: InputMaybe<Scalars['String']>;
  accountB_gte?: InputMaybe<Scalars['String']>;
  accountB_in?: InputMaybe<Array<Scalars['String']>>;
  accountB_lt?: InputMaybe<Scalars['String']>;
  accountB_lte?: InputMaybe<Scalars['String']>;
  accountB_not?: InputMaybe<Scalars['String']>;
  accountB_not_contains?: InputMaybe<Scalars['String']>;
  accountB_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountB_not_ends_with?: InputMaybe<Scalars['String']>;
  accountB_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountB_not_starts_with?: InputMaybe<Scalars['String']>;
  accountB_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_starts_with?: InputMaybe<Scalars['String']>;
  accountB_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountC?: InputMaybe<Scalars['String']>;
  accountCFirstToken?: InputMaybe<Scalars['String']>;
  accountCFirstTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountCFirstTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountCFirstTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountCFirstTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountCFirstTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountCFirstTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountCFirstTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountCFirstTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountCFirstTokenID?: InputMaybe<Scalars['Int']>;
  accountCFirstTokenID_gt?: InputMaybe<Scalars['Int']>;
  accountCFirstTokenID_gte?: InputMaybe<Scalars['Int']>;
  accountCFirstTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountCFirstTokenID_lt?: InputMaybe<Scalars['Int']>;
  accountCFirstTokenID_lte?: InputMaybe<Scalars['Int']>;
  accountCFirstTokenID_not?: InputMaybe<Scalars['Int']>;
  accountCFirstTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountCFirstToken_?: InputMaybe<Token_Filter>;
  accountCFirstToken_contains?: InputMaybe<Scalars['String']>;
  accountCFirstToken_contains_nocase?: InputMaybe<Scalars['String']>;
  accountCFirstToken_ends_with?: InputMaybe<Scalars['String']>;
  accountCFirstToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountCFirstToken_gt?: InputMaybe<Scalars['String']>;
  accountCFirstToken_gte?: InputMaybe<Scalars['String']>;
  accountCFirstToken_in?: InputMaybe<Array<Scalars['String']>>;
  accountCFirstToken_lt?: InputMaybe<Scalars['String']>;
  accountCFirstToken_lte?: InputMaybe<Scalars['String']>;
  accountCFirstToken_not?: InputMaybe<Scalars['String']>;
  accountCFirstToken_not_contains?: InputMaybe<Scalars['String']>;
  accountCFirstToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountCFirstToken_not_ends_with?: InputMaybe<Scalars['String']>;
  accountCFirstToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountCFirstToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountCFirstToken_not_starts_with?: InputMaybe<Scalars['String']>;
  accountCFirstToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountCFirstToken_starts_with?: InputMaybe<Scalars['String']>;
  accountCFirstToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountCSecondToken?: InputMaybe<Scalars['String']>;
  accountCSecondTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountCSecondTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountCSecondTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountCSecondTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountCSecondTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountCSecondTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountCSecondTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountCSecondTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountCSecondTokenID?: InputMaybe<Scalars['Int']>;
  accountCSecondTokenID_gt?: InputMaybe<Scalars['Int']>;
  accountCSecondTokenID_gte?: InputMaybe<Scalars['Int']>;
  accountCSecondTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountCSecondTokenID_lt?: InputMaybe<Scalars['Int']>;
  accountCSecondTokenID_lte?: InputMaybe<Scalars['Int']>;
  accountCSecondTokenID_not?: InputMaybe<Scalars['Int']>;
  accountCSecondTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountCSecondToken_?: InputMaybe<Token_Filter>;
  accountCSecondToken_contains?: InputMaybe<Scalars['String']>;
  accountCSecondToken_contains_nocase?: InputMaybe<Scalars['String']>;
  accountCSecondToken_ends_with?: InputMaybe<Scalars['String']>;
  accountCSecondToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountCSecondToken_gt?: InputMaybe<Scalars['String']>;
  accountCSecondToken_gte?: InputMaybe<Scalars['String']>;
  accountCSecondToken_in?: InputMaybe<Array<Scalars['String']>>;
  accountCSecondToken_lt?: InputMaybe<Scalars['String']>;
  accountCSecondToken_lte?: InputMaybe<Scalars['String']>;
  accountCSecondToken_not?: InputMaybe<Scalars['String']>;
  accountCSecondToken_not_contains?: InputMaybe<Scalars['String']>;
  accountCSecondToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountCSecondToken_not_ends_with?: InputMaybe<Scalars['String']>;
  accountCSecondToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountCSecondToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountCSecondToken_not_starts_with?: InputMaybe<Scalars['String']>;
  accountCSecondToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountCSecondToken_starts_with?: InputMaybe<Scalars['String']>;
  accountCSecondToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountC_?: InputMaybe<Account_Filter>;
  accountC_contains?: InputMaybe<Scalars['String']>;
  accountC_contains_nocase?: InputMaybe<Scalars['String']>;
  accountC_ends_with?: InputMaybe<Scalars['String']>;
  accountC_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountC_gt?: InputMaybe<Scalars['String']>;
  accountC_gte?: InputMaybe<Scalars['String']>;
  accountC_in?: InputMaybe<Array<Scalars['String']>>;
  accountC_lt?: InputMaybe<Scalars['String']>;
  accountC_lte?: InputMaybe<Scalars['String']>;
  accountC_not?: InputMaybe<Scalars['String']>;
  accountC_not_contains?: InputMaybe<Scalars['String']>;
  accountC_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountC_not_ends_with?: InputMaybe<Scalars['String']>;
  accountC_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountC_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountC_not_starts_with?: InputMaybe<Scalars['String']>;
  accountC_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountC_starts_with?: InputMaybe<Scalars['String']>;
  accountC_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountD?: InputMaybe<Scalars['String']>;
  accountDFirstToken?: InputMaybe<Scalars['String']>;
  accountDFirstTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountDFirstTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountDFirstTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountDFirstTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountDFirstTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountDFirstTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountDFirstTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountDFirstTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountDFirstTokenID?: InputMaybe<Scalars['Int']>;
  accountDFirstTokenID_gt?: InputMaybe<Scalars['Int']>;
  accountDFirstTokenID_gte?: InputMaybe<Scalars['Int']>;
  accountDFirstTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountDFirstTokenID_lt?: InputMaybe<Scalars['Int']>;
  accountDFirstTokenID_lte?: InputMaybe<Scalars['Int']>;
  accountDFirstTokenID_not?: InputMaybe<Scalars['Int']>;
  accountDFirstTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountDFirstToken_?: InputMaybe<Token_Filter>;
  accountDFirstToken_contains?: InputMaybe<Scalars['String']>;
  accountDFirstToken_contains_nocase?: InputMaybe<Scalars['String']>;
  accountDFirstToken_ends_with?: InputMaybe<Scalars['String']>;
  accountDFirstToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountDFirstToken_gt?: InputMaybe<Scalars['String']>;
  accountDFirstToken_gte?: InputMaybe<Scalars['String']>;
  accountDFirstToken_in?: InputMaybe<Array<Scalars['String']>>;
  accountDFirstToken_lt?: InputMaybe<Scalars['String']>;
  accountDFirstToken_lte?: InputMaybe<Scalars['String']>;
  accountDFirstToken_not?: InputMaybe<Scalars['String']>;
  accountDFirstToken_not_contains?: InputMaybe<Scalars['String']>;
  accountDFirstToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountDFirstToken_not_ends_with?: InputMaybe<Scalars['String']>;
  accountDFirstToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountDFirstToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountDFirstToken_not_starts_with?: InputMaybe<Scalars['String']>;
  accountDFirstToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountDFirstToken_starts_with?: InputMaybe<Scalars['String']>;
  accountDFirstToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountDSecondToken?: InputMaybe<Scalars['String']>;
  accountDSecondTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountDSecondTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountDSecondTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountDSecondTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountDSecondTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountDSecondTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountDSecondTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountDSecondTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountDSecondTokenID?: InputMaybe<Scalars['Int']>;
  accountDSecondTokenID_gt?: InputMaybe<Scalars['Int']>;
  accountDSecondTokenID_gte?: InputMaybe<Scalars['Int']>;
  accountDSecondTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountDSecondTokenID_lt?: InputMaybe<Scalars['Int']>;
  accountDSecondTokenID_lte?: InputMaybe<Scalars['Int']>;
  accountDSecondTokenID_not?: InputMaybe<Scalars['Int']>;
  accountDSecondTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountDSecondToken_?: InputMaybe<Token_Filter>;
  accountDSecondToken_contains?: InputMaybe<Scalars['String']>;
  accountDSecondToken_contains_nocase?: InputMaybe<Scalars['String']>;
  accountDSecondToken_ends_with?: InputMaybe<Scalars['String']>;
  accountDSecondToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountDSecondToken_gt?: InputMaybe<Scalars['String']>;
  accountDSecondToken_gte?: InputMaybe<Scalars['String']>;
  accountDSecondToken_in?: InputMaybe<Array<Scalars['String']>>;
  accountDSecondToken_lt?: InputMaybe<Scalars['String']>;
  accountDSecondToken_lte?: InputMaybe<Scalars['String']>;
  accountDSecondToken_not?: InputMaybe<Scalars['String']>;
  accountDSecondToken_not_contains?: InputMaybe<Scalars['String']>;
  accountDSecondToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountDSecondToken_not_ends_with?: InputMaybe<Scalars['String']>;
  accountDSecondToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountDSecondToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountDSecondToken_not_starts_with?: InputMaybe<Scalars['String']>;
  accountDSecondToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountDSecondToken_starts_with?: InputMaybe<Scalars['String']>;
  accountDSecondToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountD_?: InputMaybe<Account_Filter>;
  accountD_contains?: InputMaybe<Scalars['String']>;
  accountD_contains_nocase?: InputMaybe<Scalars['String']>;
  accountD_ends_with?: InputMaybe<Scalars['String']>;
  accountD_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountD_gt?: InputMaybe<Scalars['String']>;
  accountD_gte?: InputMaybe<Scalars['String']>;
  accountD_in?: InputMaybe<Array<Scalars['String']>>;
  accountD_lt?: InputMaybe<Scalars['String']>;
  accountD_lte?: InputMaybe<Scalars['String']>;
  accountD_not?: InputMaybe<Scalars['String']>;
  accountD_not_contains?: InputMaybe<Scalars['String']>;
  accountD_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountD_not_ends_with?: InputMaybe<Scalars['String']>;
  accountD_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountD_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountD_not_starts_with?: InputMaybe<Scalars['String']>;
  accountD_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountD_starts_with?: InputMaybe<Scalars['String']>;
  accountD_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountE?: InputMaybe<Scalars['String']>;
  accountEFirstToken?: InputMaybe<Scalars['String']>;
  accountEFirstTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountEFirstTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountEFirstTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountEFirstTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountEFirstTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountEFirstTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountEFirstTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountEFirstTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountEFirstTokenID?: InputMaybe<Scalars['Int']>;
  accountEFirstTokenID_gt?: InputMaybe<Scalars['Int']>;
  accountEFirstTokenID_gte?: InputMaybe<Scalars['Int']>;
  accountEFirstTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountEFirstTokenID_lt?: InputMaybe<Scalars['Int']>;
  accountEFirstTokenID_lte?: InputMaybe<Scalars['Int']>;
  accountEFirstTokenID_not?: InputMaybe<Scalars['Int']>;
  accountEFirstTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountEFirstToken_?: InputMaybe<Token_Filter>;
  accountEFirstToken_contains?: InputMaybe<Scalars['String']>;
  accountEFirstToken_contains_nocase?: InputMaybe<Scalars['String']>;
  accountEFirstToken_ends_with?: InputMaybe<Scalars['String']>;
  accountEFirstToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountEFirstToken_gt?: InputMaybe<Scalars['String']>;
  accountEFirstToken_gte?: InputMaybe<Scalars['String']>;
  accountEFirstToken_in?: InputMaybe<Array<Scalars['String']>>;
  accountEFirstToken_lt?: InputMaybe<Scalars['String']>;
  accountEFirstToken_lte?: InputMaybe<Scalars['String']>;
  accountEFirstToken_not?: InputMaybe<Scalars['String']>;
  accountEFirstToken_not_contains?: InputMaybe<Scalars['String']>;
  accountEFirstToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountEFirstToken_not_ends_with?: InputMaybe<Scalars['String']>;
  accountEFirstToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountEFirstToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountEFirstToken_not_starts_with?: InputMaybe<Scalars['String']>;
  accountEFirstToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountEFirstToken_starts_with?: InputMaybe<Scalars['String']>;
  accountEFirstToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountESecondToken?: InputMaybe<Scalars['String']>;
  accountESecondTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountESecondTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountESecondTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountESecondTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountESecondTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountESecondTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountESecondTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountESecondTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountESecondTokenID?: InputMaybe<Scalars['Int']>;
  accountESecondTokenID_gt?: InputMaybe<Scalars['Int']>;
  accountESecondTokenID_gte?: InputMaybe<Scalars['Int']>;
  accountESecondTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountESecondTokenID_lt?: InputMaybe<Scalars['Int']>;
  accountESecondTokenID_lte?: InputMaybe<Scalars['Int']>;
  accountESecondTokenID_not?: InputMaybe<Scalars['Int']>;
  accountESecondTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountESecondToken_?: InputMaybe<Token_Filter>;
  accountESecondToken_contains?: InputMaybe<Scalars['String']>;
  accountESecondToken_contains_nocase?: InputMaybe<Scalars['String']>;
  accountESecondToken_ends_with?: InputMaybe<Scalars['String']>;
  accountESecondToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountESecondToken_gt?: InputMaybe<Scalars['String']>;
  accountESecondToken_gte?: InputMaybe<Scalars['String']>;
  accountESecondToken_in?: InputMaybe<Array<Scalars['String']>>;
  accountESecondToken_lt?: InputMaybe<Scalars['String']>;
  accountESecondToken_lte?: InputMaybe<Scalars['String']>;
  accountESecondToken_not?: InputMaybe<Scalars['String']>;
  accountESecondToken_not_contains?: InputMaybe<Scalars['String']>;
  accountESecondToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountESecondToken_not_ends_with?: InputMaybe<Scalars['String']>;
  accountESecondToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountESecondToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountESecondToken_not_starts_with?: InputMaybe<Scalars['String']>;
  accountESecondToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountESecondToken_starts_with?: InputMaybe<Scalars['String']>;
  accountESecondToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountE_?: InputMaybe<Account_Filter>;
  accountE_contains?: InputMaybe<Scalars['String']>;
  accountE_contains_nocase?: InputMaybe<Scalars['String']>;
  accountE_ends_with?: InputMaybe<Scalars['String']>;
  accountE_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountE_gt?: InputMaybe<Scalars['String']>;
  accountE_gte?: InputMaybe<Scalars['String']>;
  accountE_in?: InputMaybe<Array<Scalars['String']>>;
  accountE_lt?: InputMaybe<Scalars['String']>;
  accountE_lte?: InputMaybe<Scalars['String']>;
  accountE_not?: InputMaybe<Scalars['String']>;
  accountE_not_contains?: InputMaybe<Scalars['String']>;
  accountE_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountE_not_ends_with?: InputMaybe<Scalars['String']>;
  accountE_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountE_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountE_not_starts_with?: InputMaybe<Scalars['String']>;
  accountE_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountE_starts_with?: InputMaybe<Scalars['String']>;
  accountE_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountF?: InputMaybe<Scalars['String']>;
  accountFFirstToken?: InputMaybe<Scalars['String']>;
  accountFFirstTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountFFirstTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountFFirstTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountFFirstTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountFFirstTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountFFirstTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountFFirstTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountFFirstTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountFFirstTokenID?: InputMaybe<Scalars['Int']>;
  accountFFirstTokenID_gt?: InputMaybe<Scalars['Int']>;
  accountFFirstTokenID_gte?: InputMaybe<Scalars['Int']>;
  accountFFirstTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountFFirstTokenID_lt?: InputMaybe<Scalars['Int']>;
  accountFFirstTokenID_lte?: InputMaybe<Scalars['Int']>;
  accountFFirstTokenID_not?: InputMaybe<Scalars['Int']>;
  accountFFirstTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountFFirstToken_?: InputMaybe<Token_Filter>;
  accountFFirstToken_contains?: InputMaybe<Scalars['String']>;
  accountFFirstToken_contains_nocase?: InputMaybe<Scalars['String']>;
  accountFFirstToken_ends_with?: InputMaybe<Scalars['String']>;
  accountFFirstToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountFFirstToken_gt?: InputMaybe<Scalars['String']>;
  accountFFirstToken_gte?: InputMaybe<Scalars['String']>;
  accountFFirstToken_in?: InputMaybe<Array<Scalars['String']>>;
  accountFFirstToken_lt?: InputMaybe<Scalars['String']>;
  accountFFirstToken_lte?: InputMaybe<Scalars['String']>;
  accountFFirstToken_not?: InputMaybe<Scalars['String']>;
  accountFFirstToken_not_contains?: InputMaybe<Scalars['String']>;
  accountFFirstToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountFFirstToken_not_ends_with?: InputMaybe<Scalars['String']>;
  accountFFirstToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountFFirstToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountFFirstToken_not_starts_with?: InputMaybe<Scalars['String']>;
  accountFFirstToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountFFirstToken_starts_with?: InputMaybe<Scalars['String']>;
  accountFFirstToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountFSecondToken?: InputMaybe<Scalars['String']>;
  accountFSecondTokenAmountExchange?: InputMaybe<Scalars['BigInt']>;
  accountFSecondTokenAmountExchange_gt?: InputMaybe<Scalars['BigInt']>;
  accountFSecondTokenAmountExchange_gte?: InputMaybe<Scalars['BigInt']>;
  accountFSecondTokenAmountExchange_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountFSecondTokenAmountExchange_lt?: InputMaybe<Scalars['BigInt']>;
  accountFSecondTokenAmountExchange_lte?: InputMaybe<Scalars['BigInt']>;
  accountFSecondTokenAmountExchange_not?: InputMaybe<Scalars['BigInt']>;
  accountFSecondTokenAmountExchange_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountFSecondTokenID?: InputMaybe<Scalars['Int']>;
  accountFSecondTokenID_gt?: InputMaybe<Scalars['Int']>;
  accountFSecondTokenID_gte?: InputMaybe<Scalars['Int']>;
  accountFSecondTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountFSecondTokenID_lt?: InputMaybe<Scalars['Int']>;
  accountFSecondTokenID_lte?: InputMaybe<Scalars['Int']>;
  accountFSecondTokenID_not?: InputMaybe<Scalars['Int']>;
  accountFSecondTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountFSecondToken_?: InputMaybe<Token_Filter>;
  accountFSecondToken_contains?: InputMaybe<Scalars['String']>;
  accountFSecondToken_contains_nocase?: InputMaybe<Scalars['String']>;
  accountFSecondToken_ends_with?: InputMaybe<Scalars['String']>;
  accountFSecondToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountFSecondToken_gt?: InputMaybe<Scalars['String']>;
  accountFSecondToken_gte?: InputMaybe<Scalars['String']>;
  accountFSecondToken_in?: InputMaybe<Array<Scalars['String']>>;
  accountFSecondToken_lt?: InputMaybe<Scalars['String']>;
  accountFSecondToken_lte?: InputMaybe<Scalars['String']>;
  accountFSecondToken_not?: InputMaybe<Scalars['String']>;
  accountFSecondToken_not_contains?: InputMaybe<Scalars['String']>;
  accountFSecondToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountFSecondToken_not_ends_with?: InputMaybe<Scalars['String']>;
  accountFSecondToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountFSecondToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountFSecondToken_not_starts_with?: InputMaybe<Scalars['String']>;
  accountFSecondToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountFSecondToken_starts_with?: InputMaybe<Scalars['String']>;
  accountFSecondToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountF_?: InputMaybe<Account_Filter>;
  accountF_contains?: InputMaybe<Scalars['String']>;
  accountF_contains_nocase?: InputMaybe<Scalars['String']>;
  accountF_ends_with?: InputMaybe<Scalars['String']>;
  accountF_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountF_gt?: InputMaybe<Scalars['String']>;
  accountF_gte?: InputMaybe<Scalars['String']>;
  accountF_in?: InputMaybe<Array<Scalars['String']>>;
  accountF_lt?: InputMaybe<Scalars['String']>;
  accountF_lte?: InputMaybe<Scalars['String']>;
  accountF_not?: InputMaybe<Scalars['String']>;
  accountF_not_contains?: InputMaybe<Scalars['String']>;
  accountF_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountF_not_ends_with?: InputMaybe<Scalars['String']>;
  accountF_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountF_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountF_not_starts_with?: InputMaybe<Scalars['String']>;
  accountF_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountF_starts_with?: InputMaybe<Scalars['String']>;
  accountF_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountIDA?: InputMaybe<Scalars['Int']>;
  accountIDA_gt?: InputMaybe<Scalars['Int']>;
  accountIDA_gte?: InputMaybe<Scalars['Int']>;
  accountIDA_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDA_lt?: InputMaybe<Scalars['Int']>;
  accountIDA_lte?: InputMaybe<Scalars['Int']>;
  accountIDA_not?: InputMaybe<Scalars['Int']>;
  accountIDA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDB?: InputMaybe<Scalars['Int']>;
  accountIDB_gt?: InputMaybe<Scalars['Int']>;
  accountIDB_gte?: InputMaybe<Scalars['Int']>;
  accountIDB_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDB_lt?: InputMaybe<Scalars['Int']>;
  accountIDB_lte?: InputMaybe<Scalars['Int']>;
  accountIDB_not?: InputMaybe<Scalars['Int']>;
  accountIDB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDC?: InputMaybe<Scalars['Int']>;
  accountIDC_gt?: InputMaybe<Scalars['Int']>;
  accountIDC_gte?: InputMaybe<Scalars['Int']>;
  accountIDC_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDC_lt?: InputMaybe<Scalars['Int']>;
  accountIDC_lte?: InputMaybe<Scalars['Int']>;
  accountIDC_not?: InputMaybe<Scalars['Int']>;
  accountIDC_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDD?: InputMaybe<Scalars['Int']>;
  accountIDD_gt?: InputMaybe<Scalars['Int']>;
  accountIDD_gte?: InputMaybe<Scalars['Int']>;
  accountIDD_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDD_lt?: InputMaybe<Scalars['Int']>;
  accountIDD_lte?: InputMaybe<Scalars['Int']>;
  accountIDD_not?: InputMaybe<Scalars['Int']>;
  accountIDD_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDE?: InputMaybe<Scalars['Int']>;
  accountIDE_gt?: InputMaybe<Scalars['Int']>;
  accountIDE_gte?: InputMaybe<Scalars['Int']>;
  accountIDE_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDE_lt?: InputMaybe<Scalars['Int']>;
  accountIDE_lte?: InputMaybe<Scalars['Int']>;
  accountIDE_not?: InputMaybe<Scalars['Int']>;
  accountIDE_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDF?: InputMaybe<Scalars['Int']>;
  accountIDF_gt?: InputMaybe<Scalars['Int']>;
  accountIDF_gte?: InputMaybe<Scalars['Int']>;
  accountIDF_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIDF_lt?: InputMaybe<Scalars['Int']>;
  accountIDF_lte?: InputMaybe<Scalars['Int']>;
  accountIDF_not?: InputMaybe<Scalars['Int']>;
  accountIDF_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  and?: InputMaybe<Array<InputMaybe<BatchSpotTrade_Filter>>>;
  bindToken?: InputMaybe<Scalars['String']>;
  bindTokenID?: InputMaybe<Scalars['Int']>;
  bindTokenID_gt?: InputMaybe<Scalars['Int']>;
  bindTokenID_gte?: InputMaybe<Scalars['Int']>;
  bindTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  bindTokenID_lt?: InputMaybe<Scalars['Int']>;
  bindTokenID_lte?: InputMaybe<Scalars['Int']>;
  bindTokenID_not?: InputMaybe<Scalars['Int']>;
  bindTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  bindToken_?: InputMaybe<Token_Filter>;
  bindToken_contains?: InputMaybe<Scalars['String']>;
  bindToken_contains_nocase?: InputMaybe<Scalars['String']>;
  bindToken_ends_with?: InputMaybe<Scalars['String']>;
  bindToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  bindToken_gt?: InputMaybe<Scalars['String']>;
  bindToken_gte?: InputMaybe<Scalars['String']>;
  bindToken_in?: InputMaybe<Array<Scalars['String']>>;
  bindToken_lt?: InputMaybe<Scalars['String']>;
  bindToken_lte?: InputMaybe<Scalars['String']>;
  bindToken_not?: InputMaybe<Scalars['String']>;
  bindToken_not_contains?: InputMaybe<Scalars['String']>;
  bindToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  bindToken_not_ends_with?: InputMaybe<Scalars['String']>;
  bindToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  bindToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  bindToken_not_starts_with?: InputMaybe<Scalars['String']>;
  bindToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  bindToken_starts_with?: InputMaybe<Scalars['String']>;
  bindToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  or?: InputMaybe<Array<InputMaybe<BatchSpotTrade_Filter>>>;
  tokenA?: InputMaybe<Scalars['String']>;
  tokenAID?: InputMaybe<Scalars['Int']>;
  tokenAID_gt?: InputMaybe<Scalars['Int']>;
  tokenAID_gte?: InputMaybe<Scalars['Int']>;
  tokenAID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenAID_lt?: InputMaybe<Scalars['Int']>;
  tokenAID_lte?: InputMaybe<Scalars['Int']>;
  tokenAID_not?: InputMaybe<Scalars['Int']>;
  tokenAID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenA_?: InputMaybe<Token_Filter>;
  tokenA_contains?: InputMaybe<Scalars['String']>;
  tokenA_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenA_ends_with?: InputMaybe<Scalars['String']>;
  tokenA_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_gt?: InputMaybe<Scalars['String']>;
  tokenA_gte?: InputMaybe<Scalars['String']>;
  tokenA_in?: InputMaybe<Array<Scalars['String']>>;
  tokenA_lt?: InputMaybe<Scalars['String']>;
  tokenA_lte?: InputMaybe<Scalars['String']>;
  tokenA_not?: InputMaybe<Scalars['String']>;
  tokenA_not_contains?: InputMaybe<Scalars['String']>;
  tokenA_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenA_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenA_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenA_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenA_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_starts_with?: InputMaybe<Scalars['String']>;
  tokenA_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB?: InputMaybe<Scalars['String']>;
  tokenBID?: InputMaybe<Scalars['Int']>;
  tokenBID_gt?: InputMaybe<Scalars['Int']>;
  tokenBID_gte?: InputMaybe<Scalars['Int']>;
  tokenBID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenBID_lt?: InputMaybe<Scalars['Int']>;
  tokenBID_lte?: InputMaybe<Scalars['Int']>;
  tokenBID_not?: InputMaybe<Scalars['Int']>;
  tokenBID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenB_?: InputMaybe<Token_Filter>;
  tokenB_contains?: InputMaybe<Scalars['String']>;
  tokenB_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenB_ends_with?: InputMaybe<Scalars['String']>;
  tokenB_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_gt?: InputMaybe<Scalars['String']>;
  tokenB_gte?: InputMaybe<Scalars['String']>;
  tokenB_in?: InputMaybe<Array<Scalars['String']>>;
  tokenB_lt?: InputMaybe<Scalars['String']>;
  tokenB_lte?: InputMaybe<Scalars['String']>;
  tokenB_not?: InputMaybe<Scalars['String']>;
  tokenB_not_contains?: InputMaybe<Scalars['String']>;
  tokenB_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenB_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenB_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenB_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenB_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_starts_with?: InputMaybe<Scalars['String']>;
  tokenB_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum BatchSpotTrade_OrderBy {
  AccountA = 'accountA',
  AccountAFirstTokenAmountExchange = 'accountAFirstTokenAmountExchange',
  AccountASecondTokenAmountExchange = 'accountASecondTokenAmountExchange',
  AccountAThirdTokenAmountExchange = 'accountAThirdTokenAmountExchange',
  AccountAAddress = 'accountA__address',
  AccountACreatedAt = 'accountA__createdAt',
  AccountAId = 'accountA__id',
  AccountAInternalId = 'accountA__internalID',
  AccountALastUpdatedAt = 'accountA__lastUpdatedAt',
  AccountB = 'accountB',
  AccountBFirstToken = 'accountBFirstToken',
  AccountBFirstTokenAmountExchange = 'accountBFirstTokenAmountExchange',
  AccountBFirstTokenId = 'accountBFirstTokenID',
  AccountBFirstTokenAddress = 'accountBFirstToken__address',
  AccountBFirstTokenDecimals = 'accountBFirstToken__decimals',
  AccountBFirstTokenId = 'accountBFirstToken__id',
  AccountBFirstTokenInternalId = 'accountBFirstToken__internalID',
  AccountBFirstTokenName = 'accountBFirstToken__name',
  AccountBFirstTokenSymbol = 'accountBFirstToken__symbol',
  AccountBFirstTokenTradedVolume = 'accountBFirstToken__tradedVolume',
  AccountBFirstTokenTradedVolumeOrderbook = 'accountBFirstToken__tradedVolumeOrderbook',
  AccountBFirstTokenTradedVolumeSwap = 'accountBFirstToken__tradedVolumeSwap',
  AccountBSecondToken = 'accountBSecondToken',
  AccountBSecondTokenAmountExchange = 'accountBSecondTokenAmountExchange',
  AccountBSecondTokenId = 'accountBSecondTokenID',
  AccountBSecondTokenAddress = 'accountBSecondToken__address',
  AccountBSecondTokenDecimals = 'accountBSecondToken__decimals',
  AccountBSecondTokenId = 'accountBSecondToken__id',
  AccountBSecondTokenInternalId = 'accountBSecondToken__internalID',
  AccountBSecondTokenName = 'accountBSecondToken__name',
  AccountBSecondTokenSymbol = 'accountBSecondToken__symbol',
  AccountBSecondTokenTradedVolume = 'accountBSecondToken__tradedVolume',
  AccountBSecondTokenTradedVolumeOrderbook = 'accountBSecondToken__tradedVolumeOrderbook',
  AccountBSecondTokenTradedVolumeSwap = 'accountBSecondToken__tradedVolumeSwap',
  AccountBAddress = 'accountB__address',
  AccountBCreatedAt = 'accountB__createdAt',
  AccountBId = 'accountB__id',
  AccountBInternalId = 'accountB__internalID',
  AccountBLastUpdatedAt = 'accountB__lastUpdatedAt',
  AccountC = 'accountC',
  AccountCFirstToken = 'accountCFirstToken',
  AccountCFirstTokenAmountExchange = 'accountCFirstTokenAmountExchange',
  AccountCFirstTokenId = 'accountCFirstTokenID',
  AccountCFirstTokenAddress = 'accountCFirstToken__address',
  AccountCFirstTokenDecimals = 'accountCFirstToken__decimals',
  AccountCFirstTokenId = 'accountCFirstToken__id',
  AccountCFirstTokenInternalId = 'accountCFirstToken__internalID',
  AccountCFirstTokenName = 'accountCFirstToken__name',
  AccountCFirstTokenSymbol = 'accountCFirstToken__symbol',
  AccountCFirstTokenTradedVolume = 'accountCFirstToken__tradedVolume',
  AccountCFirstTokenTradedVolumeOrderbook = 'accountCFirstToken__tradedVolumeOrderbook',
  AccountCFirstTokenTradedVolumeSwap = 'accountCFirstToken__tradedVolumeSwap',
  AccountCSecondToken = 'accountCSecondToken',
  AccountCSecondTokenAmountExchange = 'accountCSecondTokenAmountExchange',
  AccountCSecondTokenId = 'accountCSecondTokenID',
  AccountCSecondTokenAddress = 'accountCSecondToken__address',
  AccountCSecondTokenDecimals = 'accountCSecondToken__decimals',
  AccountCSecondTokenId = 'accountCSecondToken__id',
  AccountCSecondTokenInternalId = 'accountCSecondToken__internalID',
  AccountCSecondTokenName = 'accountCSecondToken__name',
  AccountCSecondTokenSymbol = 'accountCSecondToken__symbol',
  AccountCSecondTokenTradedVolume = 'accountCSecondToken__tradedVolume',
  AccountCSecondTokenTradedVolumeOrderbook = 'accountCSecondToken__tradedVolumeOrderbook',
  AccountCSecondTokenTradedVolumeSwap = 'accountCSecondToken__tradedVolumeSwap',
  AccountCAddress = 'accountC__address',
  AccountCCreatedAt = 'accountC__createdAt',
  AccountCId = 'accountC__id',
  AccountCInternalId = 'accountC__internalID',
  AccountCLastUpdatedAt = 'accountC__lastUpdatedAt',
  AccountD = 'accountD',
  AccountDFirstToken = 'accountDFirstToken',
  AccountDFirstTokenAmountExchange = 'accountDFirstTokenAmountExchange',
  AccountDFirstTokenId = 'accountDFirstTokenID',
  AccountDFirstTokenAddress = 'accountDFirstToken__address',
  AccountDFirstTokenDecimals = 'accountDFirstToken__decimals',
  AccountDFirstTokenId = 'accountDFirstToken__id',
  AccountDFirstTokenInternalId = 'accountDFirstToken__internalID',
  AccountDFirstTokenName = 'accountDFirstToken__name',
  AccountDFirstTokenSymbol = 'accountDFirstToken__symbol',
  AccountDFirstTokenTradedVolume = 'accountDFirstToken__tradedVolume',
  AccountDFirstTokenTradedVolumeOrderbook = 'accountDFirstToken__tradedVolumeOrderbook',
  AccountDFirstTokenTradedVolumeSwap = 'accountDFirstToken__tradedVolumeSwap',
  AccountDSecondToken = 'accountDSecondToken',
  AccountDSecondTokenAmountExchange = 'accountDSecondTokenAmountExchange',
  AccountDSecondTokenId = 'accountDSecondTokenID',
  AccountDSecondTokenAddress = 'accountDSecondToken__address',
  AccountDSecondTokenDecimals = 'accountDSecondToken__decimals',
  AccountDSecondTokenId = 'accountDSecondToken__id',
  AccountDSecondTokenInternalId = 'accountDSecondToken__internalID',
  AccountDSecondTokenName = 'accountDSecondToken__name',
  AccountDSecondTokenSymbol = 'accountDSecondToken__symbol',
  AccountDSecondTokenTradedVolume = 'accountDSecondToken__tradedVolume',
  AccountDSecondTokenTradedVolumeOrderbook = 'accountDSecondToken__tradedVolumeOrderbook',
  AccountDSecondTokenTradedVolumeSwap = 'accountDSecondToken__tradedVolumeSwap',
  AccountDAddress = 'accountD__address',
  AccountDCreatedAt = 'accountD__createdAt',
  AccountDId = 'accountD__id',
  AccountDInternalId = 'accountD__internalID',
  AccountDLastUpdatedAt = 'accountD__lastUpdatedAt',
  AccountE = 'accountE',
  AccountEFirstToken = 'accountEFirstToken',
  AccountEFirstTokenAmountExchange = 'accountEFirstTokenAmountExchange',
  AccountEFirstTokenId = 'accountEFirstTokenID',
  AccountEFirstTokenAddress = 'accountEFirstToken__address',
  AccountEFirstTokenDecimals = 'accountEFirstToken__decimals',
  AccountEFirstTokenId = 'accountEFirstToken__id',
  AccountEFirstTokenInternalId = 'accountEFirstToken__internalID',
  AccountEFirstTokenName = 'accountEFirstToken__name',
  AccountEFirstTokenSymbol = 'accountEFirstToken__symbol',
  AccountEFirstTokenTradedVolume = 'accountEFirstToken__tradedVolume',
  AccountEFirstTokenTradedVolumeOrderbook = 'accountEFirstToken__tradedVolumeOrderbook',
  AccountEFirstTokenTradedVolumeSwap = 'accountEFirstToken__tradedVolumeSwap',
  AccountESecondToken = 'accountESecondToken',
  AccountESecondTokenAmountExchange = 'accountESecondTokenAmountExchange',
  AccountESecondTokenId = 'accountESecondTokenID',
  AccountESecondTokenAddress = 'accountESecondToken__address',
  AccountESecondTokenDecimals = 'accountESecondToken__decimals',
  AccountESecondTokenId = 'accountESecondToken__id',
  AccountESecondTokenInternalId = 'accountESecondToken__internalID',
  AccountESecondTokenName = 'accountESecondToken__name',
  AccountESecondTokenSymbol = 'accountESecondToken__symbol',
  AccountESecondTokenTradedVolume = 'accountESecondToken__tradedVolume',
  AccountESecondTokenTradedVolumeOrderbook = 'accountESecondToken__tradedVolumeOrderbook',
  AccountESecondTokenTradedVolumeSwap = 'accountESecondToken__tradedVolumeSwap',
  AccountEAddress = 'accountE__address',
  AccountECreatedAt = 'accountE__createdAt',
  AccountEId = 'accountE__id',
  AccountEInternalId = 'accountE__internalID',
  AccountELastUpdatedAt = 'accountE__lastUpdatedAt',
  AccountF = 'accountF',
  AccountFFirstToken = 'accountFFirstToken',
  AccountFFirstTokenAmountExchange = 'accountFFirstTokenAmountExchange',
  AccountFFirstTokenId = 'accountFFirstTokenID',
  AccountFFirstTokenAddress = 'accountFFirstToken__address',
  AccountFFirstTokenDecimals = 'accountFFirstToken__decimals',
  AccountFFirstTokenId = 'accountFFirstToken__id',
  AccountFFirstTokenInternalId = 'accountFFirstToken__internalID',
  AccountFFirstTokenName = 'accountFFirstToken__name',
  AccountFFirstTokenSymbol = 'accountFFirstToken__symbol',
  AccountFFirstTokenTradedVolume = 'accountFFirstToken__tradedVolume',
  AccountFFirstTokenTradedVolumeOrderbook = 'accountFFirstToken__tradedVolumeOrderbook',
  AccountFFirstTokenTradedVolumeSwap = 'accountFFirstToken__tradedVolumeSwap',
  AccountFSecondToken = 'accountFSecondToken',
  AccountFSecondTokenAmountExchange = 'accountFSecondTokenAmountExchange',
  AccountFSecondTokenId = 'accountFSecondTokenID',
  AccountFSecondTokenAddress = 'accountFSecondToken__address',
  AccountFSecondTokenDecimals = 'accountFSecondToken__decimals',
  AccountFSecondTokenId = 'accountFSecondToken__id',
  AccountFSecondTokenInternalId = 'accountFSecondToken__internalID',
  AccountFSecondTokenName = 'accountFSecondToken__name',
  AccountFSecondTokenSymbol = 'accountFSecondToken__symbol',
  AccountFSecondTokenTradedVolume = 'accountFSecondToken__tradedVolume',
  AccountFSecondTokenTradedVolumeOrderbook = 'accountFSecondToken__tradedVolumeOrderbook',
  AccountFSecondTokenTradedVolumeSwap = 'accountFSecondToken__tradedVolumeSwap',
  AccountFAddress = 'accountF__address',
  AccountFCreatedAt = 'accountF__createdAt',
  AccountFId = 'accountF__id',
  AccountFInternalId = 'accountF__internalID',
  AccountFLastUpdatedAt = 'accountF__lastUpdatedAt',
  AccountIda = 'accountIDA',
  AccountIdb = 'accountIDB',
  AccountIdc = 'accountIDC',
  AccountIdd = 'accountIDD',
  AccountIde = 'accountIDE',
  AccountIdf = 'accountIDF',
  Accounts = 'accounts',
  BindToken = 'bindToken',
  BindTokenId = 'bindTokenID',
  BindTokenAddress = 'bindToken__address',
  BindTokenDecimals = 'bindToken__decimals',
  BindTokenId = 'bindToken__id',
  BindTokenInternalId = 'bindToken__internalID',
  BindTokenName = 'bindToken__name',
  BindTokenSymbol = 'bindToken__symbol',
  BindTokenTradedVolume = 'bindToken__tradedVolume',
  BindTokenTradedVolumeOrderbook = 'bindToken__tradedVolumeOrderbook',
  BindTokenTradedVolumeSwap = 'bindToken__tradedVolumeSwap',
  Block = 'block',
  BlockAccountUpdateCount = 'block__accountUpdateCount',
  BlockAccountUpdateSize = 'block__accountUpdateSize',
  BlockAddCount = 'block__addCount',
  BlockAuxiliaryData = 'block__auxiliaryData',
  BlockBlockHash = 'block__blockHash',
  BlockBlockSize = 'block__blockSize',
  BlockBlockType = 'block__blockType',
  BlockBlockVersion = 'block__blockVersion',
  BlockData = 'block__data',
  BlockDepositCount = 'block__depositCount',
  BlockDepositSize = 'block__depositSize',
  BlockExchange = 'block__exchange',
  BlockGasLimit = 'block__gasLimit',
  BlockGasPrice = 'block__gasPrice',
  BlockHeight = 'block__height',
  BlockId = 'block__id',
  BlockInternalId = 'block__internalID',
  BlockNumConditionalTransactions = 'block__numConditionalTransactions',
  BlockOffchainData = 'block__offchainData',
  BlockOperatorAccountId = 'block__operatorAccountID',
  BlockOrderbookTradeCount = 'block__orderbookTradeCount',
  BlockProtocolFeeBips = 'block__protocolFeeBips',
  BlockRemoveCount = 'block__removeCount',
  BlockSignatureVerificationCount = 'block__signatureVerificationCount',
  BlockStoreBlockInfoOnchain = 'block__storeBlockInfoOnchain',
  BlockSwapCount = 'block__swapCount',
  BlockTimestamp = 'block__timestamp',
  BlockTransactionCount = 'block__transactionCount',
  BlockTransferCount = 'block__transferCount',
  BlockTxHash = 'block__txHash',
  BlockWithdrawSize = 'block__withdrawSize',
  BlockWithdrawalCount = 'block__withdrawalCount',
  Data = 'data',
  Id = 'id',
  InternalId = 'internalID',
  TokenA = 'tokenA',
  TokenAid = 'tokenAID',
  TokenAAddress = 'tokenA__address',
  TokenADecimals = 'tokenA__decimals',
  TokenAId = 'tokenA__id',
  TokenAInternalId = 'tokenA__internalID',
  TokenAName = 'tokenA__name',
  TokenASymbol = 'tokenA__symbol',
  TokenATradedVolume = 'tokenA__tradedVolume',
  TokenATradedVolumeOrderbook = 'tokenA__tradedVolumeOrderbook',
  TokenATradedVolumeSwap = 'tokenA__tradedVolumeSwap',
  TokenB = 'tokenB',
  TokenBid = 'tokenBID',
  TokenBAddress = 'tokenB__address',
  TokenBDecimals = 'tokenB__decimals',
  TokenBId = 'tokenB__id',
  TokenBInternalId = 'tokenB__internalID',
  TokenBName = 'tokenB__name',
  TokenBSymbol = 'tokenB__symbol',
  TokenBTradedVolume = 'tokenB__tradedVolume',
  TokenBTradedVolumeOrderbook = 'tokenB__tradedVolumeOrderbook',
  TokenBTradedVolumeSwap = 'tokenB__tradedVolumeSwap',
  TokenBalances = 'tokenBalances',
  Typename = 'typename',
}

export type Block = {
  __typename?: 'Block';
  /** Total amount of AccountUpdate transactions processed on this block */
  accountUpdateCount: Scalars['BigInt'];
  /** AccountUpdateSize */
  accountUpdateSize: Scalars['Int'];
  /** Total amount of Add transactions processed on this block */
  addCount: Scalars['BigInt'];
  auxiliaryData: Scalars['String'];
  /** Hash of the L1 Block where the L2 block was submitted */
  blockHash: Scalars['String'];
  /** L2 Block size. Represents the maximum amount of L2 transactions that it could handle. */
  blockSize: Scalars['Int'];
  /** L2 Block type represented as an Integer */
  blockType: Scalars['Int'];
  /** L2 Block version */
  blockVersion: Scalars['Int'];
  /** Raw data for the L2 block. Represented as a Hex String. */
  data: Scalars['String'];
  /** Total amount of Deposit transactions processed on this block */
  depositCount: Scalars['BigInt'];
  /** Deposit Size */
  depositSize: Scalars['Int'];
  /** Exhange Address */
  exchange: Scalars['String'];
  /** Amount of gas limit used */
  gasLimit: Scalars['BigInt'];
  /** Gas price for the L1 transaction */
  gasPrice: Scalars['BigInt'];
  /** L1 Block height where the L2 Block was submitted */
  height: Scalars['BigInt'];
  id: Scalars['ID'];
  /** Same as ID but expressed as a BigInt so it can be used for sorting properly */
  internalID: Scalars['BigInt'];
  numConditionalTransactions: Scalars['Int'];
  offchainData: Scalars['Bytes'];
  /** Account entity for the operator of this L2 Block */
  operatorAccount: Account;
  /** Account ID for the operator of this L2 Block */
  operatorAccountID: Scalars['Int'];
  /** Total amount of OrderbookTrade transactions processed on this block */
  orderbookTradeCount: Scalars['BigInt'];
  /** L2 proof data */
  proof: Array<Scalars['BigInt']>;
  /** Protocol fee applied for L2 transactions within this block */
  protocolFeeBips: Scalars['Int'];
  /** Total amount of Remove transactions processed on this block */
  removeCount: Scalars['BigInt'];
  /** Total amount of SignatureVerification transactions processed on this block */
  signatureVerificationCount: Scalars['BigInt'];
  storeBlockInfoOnchain: Scalars['Boolean'];
  /** Total amount of Swap transactions processed on this block */
  swapCount: Scalars['BigInt'];
  /** L1 Block timestamp when the L2 Block was submitted */
  timestamp: Scalars['BigInt'];
  /** Total amount of transactions processed on this block. Should coincide with the lenght of the transactions list */
  transactionCount: Scalars['BigInt'];
  /** List of L2 Transactions for this L2 Block */
  transactions: Array<Transaction>;
  /** Total amount of Transfer transactions processed on this block */
  transferCount: Scalars['BigInt'];
  /** Transaction hash for the L1 Transaction where the L2 Block was submitted */
  txHash: Scalars['String'];
  /** Withdraw Size */
  withdrawSize: Scalars['Int'];
  /** Total amount of Withdrawal transactions processed on this block */
  withdrawalCount: Scalars['BigInt'];
};

export type BlockTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type BlockChangedFilter = {
  number_gte: Scalars['Int'];
};

export type Block_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountUpdateCount?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_gt?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_gte?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountUpdateCount_lt?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_lte?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_not?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountUpdateSize?: InputMaybe<Scalars['Int']>;
  accountUpdateSize_gt?: InputMaybe<Scalars['Int']>;
  accountUpdateSize_gte?: InputMaybe<Scalars['Int']>;
  accountUpdateSize_in?: InputMaybe<Array<Scalars['Int']>>;
  accountUpdateSize_lt?: InputMaybe<Scalars['Int']>;
  accountUpdateSize_lte?: InputMaybe<Scalars['Int']>;
  accountUpdateSize_not?: InputMaybe<Scalars['Int']>;
  accountUpdateSize_not_in?: InputMaybe<Array<Scalars['Int']>>;
  addCount?: InputMaybe<Scalars['BigInt']>;
  addCount_gt?: InputMaybe<Scalars['BigInt']>;
  addCount_gte?: InputMaybe<Scalars['BigInt']>;
  addCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  addCount_lt?: InputMaybe<Scalars['BigInt']>;
  addCount_lte?: InputMaybe<Scalars['BigInt']>;
  addCount_not?: InputMaybe<Scalars['BigInt']>;
  addCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<Block_Filter>>>;
  auxiliaryData?: InputMaybe<Scalars['String']>;
  auxiliaryData_contains?: InputMaybe<Scalars['String']>;
  auxiliaryData_contains_nocase?: InputMaybe<Scalars['String']>;
  auxiliaryData_ends_with?: InputMaybe<Scalars['String']>;
  auxiliaryData_ends_with_nocase?: InputMaybe<Scalars['String']>;
  auxiliaryData_gt?: InputMaybe<Scalars['String']>;
  auxiliaryData_gte?: InputMaybe<Scalars['String']>;
  auxiliaryData_in?: InputMaybe<Array<Scalars['String']>>;
  auxiliaryData_lt?: InputMaybe<Scalars['String']>;
  auxiliaryData_lte?: InputMaybe<Scalars['String']>;
  auxiliaryData_not?: InputMaybe<Scalars['String']>;
  auxiliaryData_not_contains?: InputMaybe<Scalars['String']>;
  auxiliaryData_not_contains_nocase?: InputMaybe<Scalars['String']>;
  auxiliaryData_not_ends_with?: InputMaybe<Scalars['String']>;
  auxiliaryData_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  auxiliaryData_not_in?: InputMaybe<Array<Scalars['String']>>;
  auxiliaryData_not_starts_with?: InputMaybe<Scalars['String']>;
  auxiliaryData_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  auxiliaryData_starts_with?: InputMaybe<Scalars['String']>;
  auxiliaryData_starts_with_nocase?: InputMaybe<Scalars['String']>;
  blockHash?: InputMaybe<Scalars['String']>;
  blockHash_contains?: InputMaybe<Scalars['String']>;
  blockHash_contains_nocase?: InputMaybe<Scalars['String']>;
  blockHash_ends_with?: InputMaybe<Scalars['String']>;
  blockHash_ends_with_nocase?: InputMaybe<Scalars['String']>;
  blockHash_gt?: InputMaybe<Scalars['String']>;
  blockHash_gte?: InputMaybe<Scalars['String']>;
  blockHash_in?: InputMaybe<Array<Scalars['String']>>;
  blockHash_lt?: InputMaybe<Scalars['String']>;
  blockHash_lte?: InputMaybe<Scalars['String']>;
  blockHash_not?: InputMaybe<Scalars['String']>;
  blockHash_not_contains?: InputMaybe<Scalars['String']>;
  blockHash_not_contains_nocase?: InputMaybe<Scalars['String']>;
  blockHash_not_ends_with?: InputMaybe<Scalars['String']>;
  blockHash_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  blockHash_not_in?: InputMaybe<Array<Scalars['String']>>;
  blockHash_not_starts_with?: InputMaybe<Scalars['String']>;
  blockHash_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  blockHash_starts_with?: InputMaybe<Scalars['String']>;
  blockHash_starts_with_nocase?: InputMaybe<Scalars['String']>;
  blockSize?: InputMaybe<Scalars['Int']>;
  blockSize_gt?: InputMaybe<Scalars['Int']>;
  blockSize_gte?: InputMaybe<Scalars['Int']>;
  blockSize_in?: InputMaybe<Array<Scalars['Int']>>;
  blockSize_lt?: InputMaybe<Scalars['Int']>;
  blockSize_lte?: InputMaybe<Scalars['Int']>;
  blockSize_not?: InputMaybe<Scalars['Int']>;
  blockSize_not_in?: InputMaybe<Array<Scalars['Int']>>;
  blockType?: InputMaybe<Scalars['Int']>;
  blockType_gt?: InputMaybe<Scalars['Int']>;
  blockType_gte?: InputMaybe<Scalars['Int']>;
  blockType_in?: InputMaybe<Array<Scalars['Int']>>;
  blockType_lt?: InputMaybe<Scalars['Int']>;
  blockType_lte?: InputMaybe<Scalars['Int']>;
  blockType_not?: InputMaybe<Scalars['Int']>;
  blockType_not_in?: InputMaybe<Array<Scalars['Int']>>;
  blockVersion?: InputMaybe<Scalars['Int']>;
  blockVersion_gt?: InputMaybe<Scalars['Int']>;
  blockVersion_gte?: InputMaybe<Scalars['Int']>;
  blockVersion_in?: InputMaybe<Array<Scalars['Int']>>;
  blockVersion_lt?: InputMaybe<Scalars['Int']>;
  blockVersion_lte?: InputMaybe<Scalars['Int']>;
  blockVersion_not?: InputMaybe<Scalars['Int']>;
  blockVersion_not_in?: InputMaybe<Array<Scalars['Int']>>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  depositCount?: InputMaybe<Scalars['BigInt']>;
  depositCount_gt?: InputMaybe<Scalars['BigInt']>;
  depositCount_gte?: InputMaybe<Scalars['BigInt']>;
  depositCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  depositCount_lt?: InputMaybe<Scalars['BigInt']>;
  depositCount_lte?: InputMaybe<Scalars['BigInt']>;
  depositCount_not?: InputMaybe<Scalars['BigInt']>;
  depositCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  depositSize?: InputMaybe<Scalars['Int']>;
  depositSize_gt?: InputMaybe<Scalars['Int']>;
  depositSize_gte?: InputMaybe<Scalars['Int']>;
  depositSize_in?: InputMaybe<Array<Scalars['Int']>>;
  depositSize_lt?: InputMaybe<Scalars['Int']>;
  depositSize_lte?: InputMaybe<Scalars['Int']>;
  depositSize_not?: InputMaybe<Scalars['Int']>;
  depositSize_not_in?: InputMaybe<Array<Scalars['Int']>>;
  exchange?: InputMaybe<Scalars['String']>;
  exchange_contains?: InputMaybe<Scalars['String']>;
  exchange_contains_nocase?: InputMaybe<Scalars['String']>;
  exchange_ends_with?: InputMaybe<Scalars['String']>;
  exchange_ends_with_nocase?: InputMaybe<Scalars['String']>;
  exchange_gt?: InputMaybe<Scalars['String']>;
  exchange_gte?: InputMaybe<Scalars['String']>;
  exchange_in?: InputMaybe<Array<Scalars['String']>>;
  exchange_lt?: InputMaybe<Scalars['String']>;
  exchange_lte?: InputMaybe<Scalars['String']>;
  exchange_not?: InputMaybe<Scalars['String']>;
  exchange_not_contains?: InputMaybe<Scalars['String']>;
  exchange_not_contains_nocase?: InputMaybe<Scalars['String']>;
  exchange_not_ends_with?: InputMaybe<Scalars['String']>;
  exchange_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  exchange_not_in?: InputMaybe<Array<Scalars['String']>>;
  exchange_not_starts_with?: InputMaybe<Scalars['String']>;
  exchange_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  exchange_starts_with?: InputMaybe<Scalars['String']>;
  exchange_starts_with_nocase?: InputMaybe<Scalars['String']>;
  gasLimit?: InputMaybe<Scalars['BigInt']>;
  gasLimit_gt?: InputMaybe<Scalars['BigInt']>;
  gasLimit_gte?: InputMaybe<Scalars['BigInt']>;
  gasLimit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasLimit_lt?: InputMaybe<Scalars['BigInt']>;
  gasLimit_lte?: InputMaybe<Scalars['BigInt']>;
  gasLimit_not?: InputMaybe<Scalars['BigInt']>;
  gasLimit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  height?: InputMaybe<Scalars['BigInt']>;
  height_gt?: InputMaybe<Scalars['BigInt']>;
  height_gte?: InputMaybe<Scalars['BigInt']>;
  height_in?: InputMaybe<Array<Scalars['BigInt']>>;
  height_lt?: InputMaybe<Scalars['BigInt']>;
  height_lte?: InputMaybe<Scalars['BigInt']>;
  height_not?: InputMaybe<Scalars['BigInt']>;
  height_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  numConditionalTransactions?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_gt?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_gte?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_in?: InputMaybe<Array<Scalars['Int']>>;
  numConditionalTransactions_lt?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_lte?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_not?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_not_in?: InputMaybe<Array<Scalars['Int']>>;
  offchainData?: InputMaybe<Scalars['Bytes']>;
  offchainData_contains?: InputMaybe<Scalars['Bytes']>;
  offchainData_gt?: InputMaybe<Scalars['Bytes']>;
  offchainData_gte?: InputMaybe<Scalars['Bytes']>;
  offchainData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  offchainData_lt?: InputMaybe<Scalars['Bytes']>;
  offchainData_lte?: InputMaybe<Scalars['Bytes']>;
  offchainData_not?: InputMaybe<Scalars['Bytes']>;
  offchainData_not_contains?: InputMaybe<Scalars['Bytes']>;
  offchainData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operatorAccount?: InputMaybe<Scalars['String']>;
  operatorAccountID?: InputMaybe<Scalars['Int']>;
  operatorAccountID_gt?: InputMaybe<Scalars['Int']>;
  operatorAccountID_gte?: InputMaybe<Scalars['Int']>;
  operatorAccountID_in?: InputMaybe<Array<Scalars['Int']>>;
  operatorAccountID_lt?: InputMaybe<Scalars['Int']>;
  operatorAccountID_lte?: InputMaybe<Scalars['Int']>;
  operatorAccountID_not?: InputMaybe<Scalars['Int']>;
  operatorAccountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  operatorAccount_?: InputMaybe<Account_Filter>;
  operatorAccount_contains?: InputMaybe<Scalars['String']>;
  operatorAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  operatorAccount_ends_with?: InputMaybe<Scalars['String']>;
  operatorAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  operatorAccount_gt?: InputMaybe<Scalars['String']>;
  operatorAccount_gte?: InputMaybe<Scalars['String']>;
  operatorAccount_in?: InputMaybe<Array<Scalars['String']>>;
  operatorAccount_lt?: InputMaybe<Scalars['String']>;
  operatorAccount_lte?: InputMaybe<Scalars['String']>;
  operatorAccount_not?: InputMaybe<Scalars['String']>;
  operatorAccount_not_contains?: InputMaybe<Scalars['String']>;
  operatorAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  operatorAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  operatorAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  operatorAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  operatorAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  operatorAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  operatorAccount_starts_with?: InputMaybe<Scalars['String']>;
  operatorAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<Block_Filter>>>;
  orderbookTradeCount?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_gt?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_gte?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderbookTradeCount_lt?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_lte?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_not?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  proof?: InputMaybe<Array<Scalars['BigInt']>>;
  proof_contains?: InputMaybe<Array<Scalars['BigInt']>>;
  proof_contains_nocase?: InputMaybe<Array<Scalars['BigInt']>>;
  proof_not?: InputMaybe<Array<Scalars['BigInt']>>;
  proof_not_contains?: InputMaybe<Array<Scalars['BigInt']>>;
  proof_not_contains_nocase?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeBips?: InputMaybe<Scalars['Int']>;
  protocolFeeBips_gt?: InputMaybe<Scalars['Int']>;
  protocolFeeBips_gte?: InputMaybe<Scalars['Int']>;
  protocolFeeBips_in?: InputMaybe<Array<Scalars['Int']>>;
  protocolFeeBips_lt?: InputMaybe<Scalars['Int']>;
  protocolFeeBips_lte?: InputMaybe<Scalars['Int']>;
  protocolFeeBips_not?: InputMaybe<Scalars['Int']>;
  protocolFeeBips_not_in?: InputMaybe<Array<Scalars['Int']>>;
  removeCount?: InputMaybe<Scalars['BigInt']>;
  removeCount_gt?: InputMaybe<Scalars['BigInt']>;
  removeCount_gte?: InputMaybe<Scalars['BigInt']>;
  removeCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  removeCount_lt?: InputMaybe<Scalars['BigInt']>;
  removeCount_lte?: InputMaybe<Scalars['BigInt']>;
  removeCount_not?: InputMaybe<Scalars['BigInt']>;
  removeCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  signatureVerificationCount?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_gt?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_gte?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  signatureVerificationCount_lt?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_lte?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_not?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  storeBlockInfoOnchain?: InputMaybe<Scalars['Boolean']>;
  storeBlockInfoOnchain_in?: InputMaybe<Array<Scalars['Boolean']>>;
  storeBlockInfoOnchain_not?: InputMaybe<Scalars['Boolean']>;
  storeBlockInfoOnchain_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  swapCount?: InputMaybe<Scalars['BigInt']>;
  swapCount_gt?: InputMaybe<Scalars['BigInt']>;
  swapCount_gte?: InputMaybe<Scalars['BigInt']>;
  swapCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  swapCount_lt?: InputMaybe<Scalars['BigInt']>;
  swapCount_lte?: InputMaybe<Scalars['BigInt']>;
  swapCount_not?: InputMaybe<Scalars['BigInt']>;
  swapCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionCount?: InputMaybe<Scalars['BigInt']>;
  transactionCount_gt?: InputMaybe<Scalars['BigInt']>;
  transactionCount_gte?: InputMaybe<Scalars['BigInt']>;
  transactionCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionCount_lt?: InputMaybe<Scalars['BigInt']>;
  transactionCount_lte?: InputMaybe<Scalars['BigInt']>;
  transactionCount_not?: InputMaybe<Scalars['BigInt']>;
  transactionCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactions_?: InputMaybe<Transaction_Filter>;
  transferCount?: InputMaybe<Scalars['BigInt']>;
  transferCount_gt?: InputMaybe<Scalars['BigInt']>;
  transferCount_gte?: InputMaybe<Scalars['BigInt']>;
  transferCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transferCount_lt?: InputMaybe<Scalars['BigInt']>;
  transferCount_lte?: InputMaybe<Scalars['BigInt']>;
  transferCount_not?: InputMaybe<Scalars['BigInt']>;
  transferCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  txHash?: InputMaybe<Scalars['String']>;
  txHash_contains?: InputMaybe<Scalars['String']>;
  txHash_contains_nocase?: InputMaybe<Scalars['String']>;
  txHash_ends_with?: InputMaybe<Scalars['String']>;
  txHash_ends_with_nocase?: InputMaybe<Scalars['String']>;
  txHash_gt?: InputMaybe<Scalars['String']>;
  txHash_gte?: InputMaybe<Scalars['String']>;
  txHash_in?: InputMaybe<Array<Scalars['String']>>;
  txHash_lt?: InputMaybe<Scalars['String']>;
  txHash_lte?: InputMaybe<Scalars['String']>;
  txHash_not?: InputMaybe<Scalars['String']>;
  txHash_not_contains?: InputMaybe<Scalars['String']>;
  txHash_not_contains_nocase?: InputMaybe<Scalars['String']>;
  txHash_not_ends_with?: InputMaybe<Scalars['String']>;
  txHash_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  txHash_not_in?: InputMaybe<Array<Scalars['String']>>;
  txHash_not_starts_with?: InputMaybe<Scalars['String']>;
  txHash_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  txHash_starts_with?: InputMaybe<Scalars['String']>;
  txHash_starts_with_nocase?: InputMaybe<Scalars['String']>;
  withdrawSize?: InputMaybe<Scalars['Int']>;
  withdrawSize_gt?: InputMaybe<Scalars['Int']>;
  withdrawSize_gte?: InputMaybe<Scalars['Int']>;
  withdrawSize_in?: InputMaybe<Array<Scalars['Int']>>;
  withdrawSize_lt?: InputMaybe<Scalars['Int']>;
  withdrawSize_lte?: InputMaybe<Scalars['Int']>;
  withdrawSize_not?: InputMaybe<Scalars['Int']>;
  withdrawSize_not_in?: InputMaybe<Array<Scalars['Int']>>;
  withdrawalCount?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_gt?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_gte?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  withdrawalCount_lt?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_lte?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_not?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type Block_Height = {
  hash?: InputMaybe<Scalars['Bytes']>;
  number?: InputMaybe<Scalars['Int']>;
  number_gte?: InputMaybe<Scalars['Int']>;
};

export enum Block_OrderBy {
  AccountUpdateCount = 'accountUpdateCount',
  AccountUpdateSize = 'accountUpdateSize',
  AddCount = 'addCount',
  AuxiliaryData = 'auxiliaryData',
  BlockHash = 'blockHash',
  BlockSize = 'blockSize',
  BlockType = 'blockType',
  BlockVersion = 'blockVersion',
  Data = 'data',
  DepositCount = 'depositCount',
  DepositSize = 'depositSize',
  Exchange = 'exchange',
  GasLimit = 'gasLimit',
  GasPrice = 'gasPrice',
  Height = 'height',
  Id = 'id',
  InternalId = 'internalID',
  NumConditionalTransactions = 'numConditionalTransactions',
  OffchainData = 'offchainData',
  OperatorAccount = 'operatorAccount',
  OperatorAccountId = 'operatorAccountID',
  OperatorAccountAddress = 'operatorAccount__address',
  OperatorAccountCreatedAt = 'operatorAccount__createdAt',
  OperatorAccountId = 'operatorAccount__id',
  OperatorAccountInternalId = 'operatorAccount__internalID',
  OperatorAccountLastUpdatedAt = 'operatorAccount__lastUpdatedAt',
  OrderbookTradeCount = 'orderbookTradeCount',
  Proof = 'proof',
  ProtocolFeeBips = 'protocolFeeBips',
  RemoveCount = 'removeCount',
  SignatureVerificationCount = 'signatureVerificationCount',
  StoreBlockInfoOnchain = 'storeBlockInfoOnchain',
  SwapCount = 'swapCount',
  Timestamp = 'timestamp',
  TransactionCount = 'transactionCount',
  Transactions = 'transactions',
  TransferCount = 'transferCount',
  TxHash = 'txHash',
  WithdrawSize = 'withdrawSize',
  WithdrawalCount = 'withdrawalCount',
}

export type Deposit = Transaction & {
  __typename?: 'Deposit';
  accounts?: Maybe<Array<Account>>;
  /** [RAW L2 DATA] Amount deposited */
  amount: Scalars['BigInt'];
  block: Block;
  data: Scalars['String'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] Address string of the account that deposited */
  to: Scalars['String'];
  /** Account entity that deposited the tokens */
  toAccount: Account;
  /** [RAW L2 DATA] Account ID for the account that deposited */
  toAccountID: Scalars['Int'];
  /** Token entity with information about the deposited token */
  token: Token;
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of the deposited token */
  tokenID: Scalars['Int'];
  type: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type DepositAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type DepositTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type Deposit_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<Deposit_Filter>>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  or?: InputMaybe<Array<InputMaybe<Deposit_Filter>>>;
  to?: InputMaybe<Scalars['String']>;
  toAccount?: InputMaybe<Scalars['String']>;
  toAccountID?: InputMaybe<Scalars['Int']>;
  toAccountID_gt?: InputMaybe<Scalars['Int']>;
  toAccountID_gte?: InputMaybe<Scalars['Int']>;
  toAccountID_in?: InputMaybe<Array<Scalars['Int']>>;
  toAccountID_lt?: InputMaybe<Scalars['Int']>;
  toAccountID_lte?: InputMaybe<Scalars['Int']>;
  toAccountID_not?: InputMaybe<Scalars['Int']>;
  toAccountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  toAccount_?: InputMaybe<Account_Filter>;
  toAccount_contains?: InputMaybe<Scalars['String']>;
  toAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  toAccount_ends_with?: InputMaybe<Scalars['String']>;
  toAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_gt?: InputMaybe<Scalars['String']>;
  toAccount_gte?: InputMaybe<Scalars['String']>;
  toAccount_in?: InputMaybe<Array<Scalars['String']>>;
  toAccount_lt?: InputMaybe<Scalars['String']>;
  toAccount_lte?: InputMaybe<Scalars['String']>;
  toAccount_not?: InputMaybe<Scalars['String']>;
  toAccount_not_contains?: InputMaybe<Scalars['String']>;
  toAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  toAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  toAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  toAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  toAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_starts_with?: InputMaybe<Scalars['String']>;
  toAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_contains?: InputMaybe<Scalars['String']>;
  to_contains_nocase?: InputMaybe<Scalars['String']>;
  to_ends_with?: InputMaybe<Scalars['String']>;
  to_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_gt?: InputMaybe<Scalars['String']>;
  to_gte?: InputMaybe<Scalars['String']>;
  to_in?: InputMaybe<Array<Scalars['String']>>;
  to_lt?: InputMaybe<Scalars['String']>;
  to_lte?: InputMaybe<Scalars['String']>;
  to_not?: InputMaybe<Scalars['String']>;
  to_not_contains?: InputMaybe<Scalars['String']>;
  to_not_contains_nocase?: InputMaybe<Scalars['String']>;
  to_not_ends_with?: InputMaybe<Scalars['String']>;
  to_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_not_in?: InputMaybe<Array<Scalars['String']>>;
  to_not_starts_with?: InputMaybe<Scalars['String']>;
  to_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_starts_with?: InputMaybe<Scalars['String']>;
  to_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum Deposit_OrderBy {
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  BlockAccountUpdateCount = 'block__accountUpdateCount',
  BlockAccountUpdateSize = 'block__accountUpdateSize',
  BlockAddCount = 'block__addCount',
  BlockAuxiliaryData = 'block__auxiliaryData',
  BlockBlockHash = 'block__blockHash',
  BlockBlockSize = 'block__blockSize',
  BlockBlockType = 'block__blockType',
  BlockBlockVersion = 'block__blockVersion',
  BlockData = 'block__data',
  BlockDepositCount = 'block__depositCount',
  BlockDepositSize = 'block__depositSize',
  BlockExchange = 'block__exchange',
  BlockGasLimit = 'block__gasLimit',
  BlockGasPrice = 'block__gasPrice',
  BlockHeight = 'block__height',
  BlockId = 'block__id',
  BlockInternalId = 'block__internalID',
  BlockNumConditionalTransactions = 'block__numConditionalTransactions',
  BlockOffchainData = 'block__offchainData',
  BlockOperatorAccountId = 'block__operatorAccountID',
  BlockOrderbookTradeCount = 'block__orderbookTradeCount',
  BlockProtocolFeeBips = 'block__protocolFeeBips',
  BlockRemoveCount = 'block__removeCount',
  BlockSignatureVerificationCount = 'block__signatureVerificationCount',
  BlockStoreBlockInfoOnchain = 'block__storeBlockInfoOnchain',
  BlockSwapCount = 'block__swapCount',
  BlockTimestamp = 'block__timestamp',
  BlockTransactionCount = 'block__transactionCount',
  BlockTransferCount = 'block__transferCount',
  BlockTxHash = 'block__txHash',
  BlockWithdrawSize = 'block__withdrawSize',
  BlockWithdrawalCount = 'block__withdrawalCount',
  Data = 'data',
  Id = 'id',
  InternalId = 'internalID',
  To = 'to',
  ToAccount = 'toAccount',
  ToAccountId = 'toAccountID',
  ToAccountAddress = 'toAccount__address',
  ToAccountCreatedAt = 'toAccount__createdAt',
  ToAccountId = 'toAccount__id',
  ToAccountInternalId = 'toAccount__internalID',
  ToAccountLastUpdatedAt = 'toAccount__lastUpdatedAt',
  Token = 'token',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  TokenAddress = 'token__address',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenInternalId = 'token__internalID',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenTradedVolume = 'token__tradedVolume',
  TokenTradedVolumeOrderbook = 'token__tradedVolumeOrderbook',
  TokenTradedVolumeSwap = 'token__tradedVolumeSwap',
  Type = 'type',
  Typename = 'typename',
}

export type Exchange = {
  __typename?: 'Exchange';
  /** Address of the exchange implementation */
  id: Scalars['ID'];
  /** Proxy link. Used to generate derived array of implementations. */
  proxy: Proxy;
  /** List of all tokens supported during the time this Exchange was the current implementation */
  tokens: Array<Token>;
};

export type ExchangeTokensArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Token_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Token_Filter>;
};

export type Exchange_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Exchange_Filter>>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<Exchange_Filter>>>;
  proxy?: InputMaybe<Scalars['String']>;
  proxy_?: InputMaybe<Proxy_Filter>;
  proxy_contains?: InputMaybe<Scalars['String']>;
  proxy_contains_nocase?: InputMaybe<Scalars['String']>;
  proxy_ends_with?: InputMaybe<Scalars['String']>;
  proxy_ends_with_nocase?: InputMaybe<Scalars['String']>;
  proxy_gt?: InputMaybe<Scalars['String']>;
  proxy_gte?: InputMaybe<Scalars['String']>;
  proxy_in?: InputMaybe<Array<Scalars['String']>>;
  proxy_lt?: InputMaybe<Scalars['String']>;
  proxy_lte?: InputMaybe<Scalars['String']>;
  proxy_not?: InputMaybe<Scalars['String']>;
  proxy_not_contains?: InputMaybe<Scalars['String']>;
  proxy_not_contains_nocase?: InputMaybe<Scalars['String']>;
  proxy_not_ends_with?: InputMaybe<Scalars['String']>;
  proxy_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  proxy_not_in?: InputMaybe<Array<Scalars['String']>>;
  proxy_not_starts_with?: InputMaybe<Scalars['String']>;
  proxy_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  proxy_starts_with?: InputMaybe<Scalars['String']>;
  proxy_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokens_?: InputMaybe<Token_Filter>;
};

export enum Exchange_OrderBy {
  Id = 'id',
  Proxy = 'proxy',
  ProxyAccountUpdateCount = 'proxy__accountUpdateCount',
  ProxyAddCount = 'proxy__addCount',
  ProxyBlockCount = 'proxy__blockCount',
  ProxyDepositCount = 'proxy__depositCount',
  ProxyId = 'proxy__id',
  ProxyOrderbookTradeCount = 'proxy__orderbookTradeCount',
  ProxyRemoveCount = 'proxy__removeCount',
  ProxySignatureVerificationCount = 'proxy__signatureVerificationCount',
  ProxySwapCount = 'proxy__swapCount',
  ProxyTokenCount = 'proxy__tokenCount',
  ProxyTransactionCount = 'proxy__transactionCount',
  ProxyTransferCount = 'proxy__transferCount',
  ProxyUserCount = 'proxy__userCount',
  ProxyWithdrawalCount = 'proxy__withdrawalCount',
  Tokens = 'tokens',
}

/** Defines the order direction, either ascending or descending */
export enum OrderDirection {
  Asc = 'asc',
  Desc = 'desc',
}

export type OrderbookTrade = Transaction & {
  __typename?: 'OrderbookTrade';
  /** Account entity A */
  accountA: Account;
  /** Account entity B */
  accountB: Account;
  /** [RAW L2 DATA] Account ID of account A */
  accountIdA: Scalars['Int'];
  /** [RAW L2 DATA] Account ID of account B */
  accountIdB: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Float encoded value for fillSA represented as an Int */
  fFillSA: Scalars['Int'];
  /** [RAW L2 DATA] Float encoded value for fillSB represented as an Int */
  fFillSB: Scalars['Int'];
  /** [RAW L2 DATA] Fee paid by Account A with Token B */
  feeA: Scalars['BigInt'];
  /** [RAW L2 DATA] Fee paid by Account B with token A */
  feeB: Scalars['BigInt'];
  /** [RAW L2 DATA] Fee bips for order A */
  feeBipsA: Scalars['BigInt'];
  /** [RAW L2 DATA] Fee bips for order B */
  feeBipsB: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data A */
  feeBipsHiA: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data B */
  feeBipsHiB: Scalars['BigInt'];
  /** [RAW L2 DATA] Is fill amount for buy or sell for order A */
  fillAmountBorSA: Scalars['Boolean'];
  /** [RAW L2 DATA] Is fill amount for buy or sell for order B */
  fillAmountBorSB: Scalars['Boolean'];
  /** [RAW L2 DATA] Amount of token B bought by Account A */
  fillBA: Scalars['BigInt'];
  /** [RAW L2 DATA] Amount of token A bought by Account B */
  fillBB: Scalars['BigInt'];
  /** [RAW L2 DATA] Amount of token A sold by Account A */
  fillSA: Scalars['BigInt'];
  /** [RAW L2 DATA] Amount of token B sold by Account B */
  fillSB: Scalars['BigInt'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] Limit mask value for order A */
  limitMaskA: Scalars['BigInt'];
  /** [RAW L2 DATA] Limit mask value for order B */
  limitMaskB: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data A */
  orderDataA: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data B */
  orderDataB: Scalars['BigInt'];
  /** Standardized Pair entity for this trade */
  pair: Pair;
  /** [RAW L2 DATA] Protocol fees paid by Account A */
  protocolFeeA: Scalars['BigInt'];
  /** [RAW L2 DATA] Protocol fees paid by Account B */
  protocolFeeB: Scalars['BigInt'];
  /** [RAW L2 DATA] StorageID for account A */
  storageIdA: Scalars['Int'];
  /** [RAW L2 DATA] StorageID for account B */
  storageIdB: Scalars['Int'];
  /** Token A. Supplied by Account A */
  tokenA: Token;
  /** Price for 1 unit of token A for this trade. Denominated in token B */
  tokenAPrice: Scalars['BigInt'];
  /** Token B. Supplied by Account B */
  tokenB: Token;
  /** Price for 1 unit of token B for this trade. Denominated in token A */
  tokenBPrice: Scalars['BigInt'];
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of token bought by account A. Should coincide with tokenIDBS */
  tokenIDAB: Scalars['Int'];
  /** [RAW L2 DATA] Token ID of token sold by account A */
  tokenIDAS: Scalars['Int'];
  /** [RAW L2 DATA] Token ID of token bought by account B. Should coincide with tokenIDAS */
  tokenIDBB: Scalars['Int'];
  /** [RAW L2 DATA] Token ID of token sold by account B */
  tokenIDBS: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type OrderbookTradeAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type OrderbookTradeTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type OrderbookTrade_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountA?: InputMaybe<Scalars['String']>;
  accountA_?: InputMaybe<Account_Filter>;
  accountA_contains?: InputMaybe<Scalars['String']>;
  accountA_contains_nocase?: InputMaybe<Scalars['String']>;
  accountA_ends_with?: InputMaybe<Scalars['String']>;
  accountA_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_gt?: InputMaybe<Scalars['String']>;
  accountA_gte?: InputMaybe<Scalars['String']>;
  accountA_in?: InputMaybe<Array<Scalars['String']>>;
  accountA_lt?: InputMaybe<Scalars['String']>;
  accountA_lte?: InputMaybe<Scalars['String']>;
  accountA_not?: InputMaybe<Scalars['String']>;
  accountA_not_contains?: InputMaybe<Scalars['String']>;
  accountA_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountA_not_ends_with?: InputMaybe<Scalars['String']>;
  accountA_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountA_not_starts_with?: InputMaybe<Scalars['String']>;
  accountA_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_starts_with?: InputMaybe<Scalars['String']>;
  accountA_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountB?: InputMaybe<Scalars['String']>;
  accountB_?: InputMaybe<Account_Filter>;
  accountB_contains?: InputMaybe<Scalars['String']>;
  accountB_contains_nocase?: InputMaybe<Scalars['String']>;
  accountB_ends_with?: InputMaybe<Scalars['String']>;
  accountB_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_gt?: InputMaybe<Scalars['String']>;
  accountB_gte?: InputMaybe<Scalars['String']>;
  accountB_in?: InputMaybe<Array<Scalars['String']>>;
  accountB_lt?: InputMaybe<Scalars['String']>;
  accountB_lte?: InputMaybe<Scalars['String']>;
  accountB_not?: InputMaybe<Scalars['String']>;
  accountB_not_contains?: InputMaybe<Scalars['String']>;
  accountB_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountB_not_ends_with?: InputMaybe<Scalars['String']>;
  accountB_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountB_not_starts_with?: InputMaybe<Scalars['String']>;
  accountB_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_starts_with?: InputMaybe<Scalars['String']>;
  accountB_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountIdA?: InputMaybe<Scalars['Int']>;
  accountIdA_gt?: InputMaybe<Scalars['Int']>;
  accountIdA_gte?: InputMaybe<Scalars['Int']>;
  accountIdA_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdA_lt?: InputMaybe<Scalars['Int']>;
  accountIdA_lte?: InputMaybe<Scalars['Int']>;
  accountIdA_not?: InputMaybe<Scalars['Int']>;
  accountIdA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdB?: InputMaybe<Scalars['Int']>;
  accountIdB_gt?: InputMaybe<Scalars['Int']>;
  accountIdB_gte?: InputMaybe<Scalars['Int']>;
  accountIdB_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdB_lt?: InputMaybe<Scalars['Int']>;
  accountIdB_lte?: InputMaybe<Scalars['Int']>;
  accountIdB_not?: InputMaybe<Scalars['Int']>;
  accountIdB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  and?: InputMaybe<Array<InputMaybe<OrderbookTrade_Filter>>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fFillSA?: InputMaybe<Scalars['Int']>;
  fFillSA_gt?: InputMaybe<Scalars['Int']>;
  fFillSA_gte?: InputMaybe<Scalars['Int']>;
  fFillSA_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSA_lt?: InputMaybe<Scalars['Int']>;
  fFillSA_lte?: InputMaybe<Scalars['Int']>;
  fFillSA_not?: InputMaybe<Scalars['Int']>;
  fFillSA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSB?: InputMaybe<Scalars['Int']>;
  fFillSB_gt?: InputMaybe<Scalars['Int']>;
  fFillSB_gte?: InputMaybe<Scalars['Int']>;
  fFillSB_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSB_lt?: InputMaybe<Scalars['Int']>;
  fFillSB_lte?: InputMaybe<Scalars['Int']>;
  fFillSB_not?: InputMaybe<Scalars['Int']>;
  fFillSB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeA?: InputMaybe<Scalars['BigInt']>;
  feeA_gt?: InputMaybe<Scalars['BigInt']>;
  feeA_gte?: InputMaybe<Scalars['BigInt']>;
  feeA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeA_lt?: InputMaybe<Scalars['BigInt']>;
  feeA_lte?: InputMaybe<Scalars['BigInt']>;
  feeA_not?: InputMaybe<Scalars['BigInt']>;
  feeA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeB?: InputMaybe<Scalars['BigInt']>;
  feeB_gt?: InputMaybe<Scalars['BigInt']>;
  feeB_gte?: InputMaybe<Scalars['BigInt']>;
  feeB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeB_lt?: InputMaybe<Scalars['BigInt']>;
  feeB_lte?: InputMaybe<Scalars['BigInt']>;
  feeB_not?: InputMaybe<Scalars['BigInt']>;
  feeB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsA?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsA_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsB?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsB_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiA?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiA_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiB?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiB_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillAmountBorSA?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSA_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSA_not?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSA_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSB?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSB_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSB_not?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSB_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillBA?: InputMaybe<Scalars['BigInt']>;
  fillBA_gt?: InputMaybe<Scalars['BigInt']>;
  fillBA_gte?: InputMaybe<Scalars['BigInt']>;
  fillBA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBA_lt?: InputMaybe<Scalars['BigInt']>;
  fillBA_lte?: InputMaybe<Scalars['BigInt']>;
  fillBA_not?: InputMaybe<Scalars['BigInt']>;
  fillBA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBB?: InputMaybe<Scalars['BigInt']>;
  fillBB_gt?: InputMaybe<Scalars['BigInt']>;
  fillBB_gte?: InputMaybe<Scalars['BigInt']>;
  fillBB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBB_lt?: InputMaybe<Scalars['BigInt']>;
  fillBB_lte?: InputMaybe<Scalars['BigInt']>;
  fillBB_not?: InputMaybe<Scalars['BigInt']>;
  fillBB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSA?: InputMaybe<Scalars['BigInt']>;
  fillSA_gt?: InputMaybe<Scalars['BigInt']>;
  fillSA_gte?: InputMaybe<Scalars['BigInt']>;
  fillSA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSA_lt?: InputMaybe<Scalars['BigInt']>;
  fillSA_lte?: InputMaybe<Scalars['BigInt']>;
  fillSA_not?: InputMaybe<Scalars['BigInt']>;
  fillSA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSB?: InputMaybe<Scalars['BigInt']>;
  fillSB_gt?: InputMaybe<Scalars['BigInt']>;
  fillSB_gte?: InputMaybe<Scalars['BigInt']>;
  fillSB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSB_lt?: InputMaybe<Scalars['BigInt']>;
  fillSB_lte?: InputMaybe<Scalars['BigInt']>;
  fillSB_not?: InputMaybe<Scalars['BigInt']>;
  fillSB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  limitMaskA?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_gt?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_gte?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskA_lt?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_lte?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_not?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskB?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_gt?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_gte?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskB_lt?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_lte?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_not?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  or?: InputMaybe<Array<InputMaybe<OrderbookTrade_Filter>>>;
  orderDataA?: InputMaybe<Scalars['BigInt']>;
  orderDataA_gt?: InputMaybe<Scalars['BigInt']>;
  orderDataA_gte?: InputMaybe<Scalars['BigInt']>;
  orderDataA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataA_lt?: InputMaybe<Scalars['BigInt']>;
  orderDataA_lte?: InputMaybe<Scalars['BigInt']>;
  orderDataA_not?: InputMaybe<Scalars['BigInt']>;
  orderDataA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataB?: InputMaybe<Scalars['BigInt']>;
  orderDataB_gt?: InputMaybe<Scalars['BigInt']>;
  orderDataB_gte?: InputMaybe<Scalars['BigInt']>;
  orderDataB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataB_lt?: InputMaybe<Scalars['BigInt']>;
  orderDataB_lte?: InputMaybe<Scalars['BigInt']>;
  orderDataB_not?: InputMaybe<Scalars['BigInt']>;
  orderDataB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  pair?: InputMaybe<Scalars['String']>;
  pair_?: InputMaybe<Pair_Filter>;
  pair_contains?: InputMaybe<Scalars['String']>;
  pair_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_ends_with?: InputMaybe<Scalars['String']>;
  pair_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_gt?: InputMaybe<Scalars['String']>;
  pair_gte?: InputMaybe<Scalars['String']>;
  pair_in?: InputMaybe<Array<Scalars['String']>>;
  pair_lt?: InputMaybe<Scalars['String']>;
  pair_lte?: InputMaybe<Scalars['String']>;
  pair_not?: InputMaybe<Scalars['String']>;
  pair_not_contains?: InputMaybe<Scalars['String']>;
  pair_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_not_ends_with?: InputMaybe<Scalars['String']>;
  pair_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_not_in?: InputMaybe<Array<Scalars['String']>>;
  pair_not_starts_with?: InputMaybe<Scalars['String']>;
  pair_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pair_starts_with?: InputMaybe<Scalars['String']>;
  pair_starts_with_nocase?: InputMaybe<Scalars['String']>;
  protocolFeeA?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_gt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_gte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeA_lt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_lte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_not?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeB?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_gt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_gte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeB_lt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_lte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_not?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  storageIdA?: InputMaybe<Scalars['Int']>;
  storageIdA_gt?: InputMaybe<Scalars['Int']>;
  storageIdA_gte?: InputMaybe<Scalars['Int']>;
  storageIdA_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdA_lt?: InputMaybe<Scalars['Int']>;
  storageIdA_lte?: InputMaybe<Scalars['Int']>;
  storageIdA_not?: InputMaybe<Scalars['Int']>;
  storageIdA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdB?: InputMaybe<Scalars['Int']>;
  storageIdB_gt?: InputMaybe<Scalars['Int']>;
  storageIdB_gte?: InputMaybe<Scalars['Int']>;
  storageIdB_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdB_lt?: InputMaybe<Scalars['Int']>;
  storageIdB_lte?: InputMaybe<Scalars['Int']>;
  storageIdB_not?: InputMaybe<Scalars['Int']>;
  storageIdB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenA?: InputMaybe<Scalars['String']>;
  tokenAPrice?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_gt?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_gte?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenAPrice_lt?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_lte?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_not?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenA_?: InputMaybe<Token_Filter>;
  tokenA_contains?: InputMaybe<Scalars['String']>;
  tokenA_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenA_ends_with?: InputMaybe<Scalars['String']>;
  tokenA_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_gt?: InputMaybe<Scalars['String']>;
  tokenA_gte?: InputMaybe<Scalars['String']>;
  tokenA_in?: InputMaybe<Array<Scalars['String']>>;
  tokenA_lt?: InputMaybe<Scalars['String']>;
  tokenA_lte?: InputMaybe<Scalars['String']>;
  tokenA_not?: InputMaybe<Scalars['String']>;
  tokenA_not_contains?: InputMaybe<Scalars['String']>;
  tokenA_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenA_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenA_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenA_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenA_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_starts_with?: InputMaybe<Scalars['String']>;
  tokenA_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB?: InputMaybe<Scalars['String']>;
  tokenBPrice?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_gt?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_gte?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenBPrice_lt?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_lte?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_not?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenB_?: InputMaybe<Token_Filter>;
  tokenB_contains?: InputMaybe<Scalars['String']>;
  tokenB_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenB_ends_with?: InputMaybe<Scalars['String']>;
  tokenB_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_gt?: InputMaybe<Scalars['String']>;
  tokenB_gte?: InputMaybe<Scalars['String']>;
  tokenB_in?: InputMaybe<Array<Scalars['String']>>;
  tokenB_lt?: InputMaybe<Scalars['String']>;
  tokenB_lte?: InputMaybe<Scalars['String']>;
  tokenB_not?: InputMaybe<Scalars['String']>;
  tokenB_not_contains?: InputMaybe<Scalars['String']>;
  tokenB_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenB_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenB_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenB_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenB_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_starts_with?: InputMaybe<Scalars['String']>;
  tokenB_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenIDAB?: InputMaybe<Scalars['Int']>;
  tokenIDAB_gt?: InputMaybe<Scalars['Int']>;
  tokenIDAB_gte?: InputMaybe<Scalars['Int']>;
  tokenIDAB_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAB_lt?: InputMaybe<Scalars['Int']>;
  tokenIDAB_lte?: InputMaybe<Scalars['Int']>;
  tokenIDAB_not?: InputMaybe<Scalars['Int']>;
  tokenIDAB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAS?: InputMaybe<Scalars['Int']>;
  tokenIDAS_gt?: InputMaybe<Scalars['Int']>;
  tokenIDAS_gte?: InputMaybe<Scalars['Int']>;
  tokenIDAS_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAS_lt?: InputMaybe<Scalars['Int']>;
  tokenIDAS_lte?: InputMaybe<Scalars['Int']>;
  tokenIDAS_not?: InputMaybe<Scalars['Int']>;
  tokenIDAS_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBB?: InputMaybe<Scalars['Int']>;
  tokenIDBB_gt?: InputMaybe<Scalars['Int']>;
  tokenIDBB_gte?: InputMaybe<Scalars['Int']>;
  tokenIDBB_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBB_lt?: InputMaybe<Scalars['Int']>;
  tokenIDBB_lte?: InputMaybe<Scalars['Int']>;
  tokenIDBB_not?: InputMaybe<Scalars['Int']>;
  tokenIDBB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBS?: InputMaybe<Scalars['Int']>;
  tokenIDBS_gt?: InputMaybe<Scalars['Int']>;
  tokenIDBS_gte?: InputMaybe<Scalars['Int']>;
  tokenIDBS_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBS_lt?: InputMaybe<Scalars['Int']>;
  tokenIDBS_lte?: InputMaybe<Scalars['Int']>;
  tokenIDBS_not?: InputMaybe<Scalars['Int']>;
  tokenIDBS_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum OrderbookTrade_OrderBy {
  AccountA = 'accountA',
  AccountAAddress = 'accountA__address',
  AccountACreatedAt = 'accountA__createdAt',
  AccountAId = 'accountA__id',
  AccountAInternalId = 'accountA__internalID',
  AccountALastUpdatedAt = 'accountA__lastUpdatedAt',
  AccountB = 'accountB',
  AccountBAddress = 'accountB__address',
  AccountBCreatedAt = 'accountB__createdAt',
  AccountBId = 'accountB__id',
  AccountBInternalId = 'accountB__internalID',
  AccountBLastUpdatedAt = 'accountB__lastUpdatedAt',
  AccountIdA = 'accountIdA',
  AccountIdB = 'accountIdB',
  Accounts = 'accounts',
  Block = 'block',
  BlockAccountUpdateCount = 'block__accountUpdateCount',
  BlockAccountUpdateSize = 'block__accountUpdateSize',
  BlockAddCount = 'block__addCount',
  BlockAuxiliaryData = 'block__auxiliaryData',
  BlockBlockHash = 'block__blockHash',
  BlockBlockSize = 'block__blockSize',
  BlockBlockType = 'block__blockType',
  BlockBlockVersion = 'block__blockVersion',
  BlockData = 'block__data',
  BlockDepositCount = 'block__depositCount',
  BlockDepositSize = 'block__depositSize',
  BlockExchange = 'block__exchange',
  BlockGasLimit = 'block__gasLimit',
  BlockGasPrice = 'block__gasPrice',
  BlockHeight = 'block__height',
  BlockId = 'block__id',
  BlockInternalId = 'block__internalID',
  BlockNumConditionalTransactions = 'block__numConditionalTransactions',
  BlockOffchainData = 'block__offchainData',
  BlockOperatorAccountId = 'block__operatorAccountID',
  BlockOrderbookTradeCount = 'block__orderbookTradeCount',
  BlockProtocolFeeBips = 'block__protocolFeeBips',
  BlockRemoveCount = 'block__removeCount',
  BlockSignatureVerificationCount = 'block__signatureVerificationCount',
  BlockStoreBlockInfoOnchain = 'block__storeBlockInfoOnchain',
  BlockSwapCount = 'block__swapCount',
  BlockTimestamp = 'block__timestamp',
  BlockTransactionCount = 'block__transactionCount',
  BlockTransferCount = 'block__transferCount',
  BlockTxHash = 'block__txHash',
  BlockWithdrawSize = 'block__withdrawSize',
  BlockWithdrawalCount = 'block__withdrawalCount',
  Data = 'data',
  FFillSa = 'fFillSA',
  FFillSb = 'fFillSB',
  FeeA = 'feeA',
  FeeB = 'feeB',
  FeeBipsA = 'feeBipsA',
  FeeBipsB = 'feeBipsB',
  FeeBipsHiA = 'feeBipsHiA',
  FeeBipsHiB = 'feeBipsHiB',
  FillAmountBorSa = 'fillAmountBorSA',
  FillAmountBorSb = 'fillAmountBorSB',
  FillBa = 'fillBA',
  FillBb = 'fillBB',
  FillSa = 'fillSA',
  FillSb = 'fillSB',
  Id = 'id',
  InternalId = 'internalID',
  LimitMaskA = 'limitMaskA',
  LimitMaskB = 'limitMaskB',
  OrderDataA = 'orderDataA',
  OrderDataB = 'orderDataB',
  Pair = 'pair',
  PairId = 'pair__id',
  PairInternalId = 'pair__internalID',
  PairToken0Price = 'pair__token0Price',
  PairToken1Price = 'pair__token1Price',
  PairTradedVolumeToken0 = 'pair__tradedVolumeToken0',
  PairTradedVolumeToken0Orderbook = 'pair__tradedVolumeToken0Orderbook',
  PairTradedVolumeToken0Swap = 'pair__tradedVolumeToken0Swap',
  PairTradedVolumeToken1 = 'pair__tradedVolumeToken1',
  PairTradedVolumeToken1Orderbook = 'pair__tradedVolumeToken1Orderbook',
  PairTradedVolumeToken1Swap = 'pair__tradedVolumeToken1Swap',
  ProtocolFeeA = 'protocolFeeA',
  ProtocolFeeB = 'protocolFeeB',
  StorageIdA = 'storageIdA',
  StorageIdB = 'storageIdB',
  TokenA = 'tokenA',
  TokenAPrice = 'tokenAPrice',
  TokenAAddress = 'tokenA__address',
  TokenADecimals = 'tokenA__decimals',
  TokenAId = 'tokenA__id',
  TokenAInternalId = 'tokenA__internalID',
  TokenAName = 'tokenA__name',
  TokenASymbol = 'tokenA__symbol',
  TokenATradedVolume = 'tokenA__tradedVolume',
  TokenATradedVolumeOrderbook = 'tokenA__tradedVolumeOrderbook',
  TokenATradedVolumeSwap = 'tokenA__tradedVolumeSwap',
  TokenB = 'tokenB',
  TokenBPrice = 'tokenBPrice',
  TokenBAddress = 'tokenB__address',
  TokenBDecimals = 'tokenB__decimals',
  TokenBId = 'tokenB__id',
  TokenBInternalId = 'tokenB__internalID',
  TokenBName = 'tokenB__name',
  TokenBSymbol = 'tokenB__symbol',
  TokenBTradedVolume = 'tokenB__tradedVolume',
  TokenBTradedVolumeOrderbook = 'tokenB__tradedVolumeOrderbook',
  TokenBTradedVolumeSwap = 'tokenB__tradedVolumeSwap',
  TokenBalances = 'tokenBalances',
  TokenIdab = 'tokenIDAB',
  TokenIdas = 'tokenIDAS',
  TokenIdbb = 'tokenIDBB',
  TokenIdbs = 'tokenIDBS',
  Typename = 'typename',
}

export type Pair = {
  __typename?: 'Pair';
  dailyEntities: Array<PairDailyData>;
  /** ID is recreated following the next pattern to standardize pair IDs: <LOWEST Token ID>-<HIGHEST Token ID> */
  id: Scalars['ID'];
  /** ID represented as a decimal number. Follows the same pattern but with a comma instead */
  internalID: Scalars['BigDecimal'];
  token0: Token;
  /** Last price of Token 0. Denominated in Token 1 */
  token0Price: Scalars['BigInt'];
  token1: Token;
  /** Last price of Token 1. Denominated in Token 0 */
  token1Price: Scalars['BigInt'];
  /** Total traded volume of token0 within this pair. Includes both Swaps and Orderbook trades. Denominated in it's own currency */
  tradedVolumeToken0: Scalars['BigInt'];
  /** Total traded volume of token0 within this pair exclusively on Orderbook trades. Denominated in it's own currency */
  tradedVolumeToken0Orderbook: Scalars['BigInt'];
  /** Total traded volume of token0 within this pair exclusively on Swaps. Denominated in it's own currency */
  tradedVolumeToken0Swap: Scalars['BigInt'];
  /** Total traded volume of token1 within this pair. Includes both Swaps and Orderbook trades. Denominated in it's own currency */
  tradedVolumeToken1: Scalars['BigInt'];
  /** Total traded volume of token1 within this pair exclusively on Orderbook trades. Denominated in it's own currency */
  tradedVolumeToken1Orderbook: Scalars['BigInt'];
  /** Total traded volume of token1 within this pair exclusively on Swaps. Denominated in it's own currency */
  tradedVolumeToken1Swap: Scalars['BigInt'];
  trades: Array<OrderbookTrade>;
  weeklyEntities: Array<PairWeeklyData>;
};

export type PairDailyEntitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PairDailyData_Filter>;
};

export type PairTradesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OrderbookTrade_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<OrderbookTrade_Filter>;
};

export type PairWeeklyEntitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PairWeeklyData_Filter>;
};

export type PairDailyData = {
  __typename?: 'PairDailyData';
  /** Timestamp of the end of the day. Timezone -> UTC */
  dayEnd: Scalars['BigInt'];
  /** Day number is the amount of days since the start block of Loopring 3.6 (block 11149814) */
  dayNumber: Scalars['Int'];
  /** Timestamp of the start of the day. Timezone -> UTC */
  dayStart: Scalars['BigInt'];
  /** The ID follows this pattern: <PAIR ID>-<DAY NUMBER>. */
  id: Scalars['ID'];
  pair: Pair;
  /** Price for token 0 at the end of the time interval */
  token0PriceClose: Scalars['BigInt'];
  /** Highest price for token 0 during the time interval */
  token0PriceHigh: Scalars['BigInt'];
  /** Lowest price for token 0 during the time interval */
  token0PriceLow: Scalars['BigInt'];
  /** Price for token 0 at the start of the time interval */
  token0PriceOpen: Scalars['BigInt'];
  /** Price for token 1 at the end of the time interval */
  token1PriceClose: Scalars['BigInt'];
  /** Highest price for token 1 during the time interval */
  token1PriceHigh: Scalars['BigInt'];
  /** Lowest price for token 1 during the time interval */
  token1PriceLow: Scalars['BigInt'];
  /** Price for token 1 at the start of the time interval */
  token1PriceOpen: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair. Includes both Swaps and Orderbook trades */
  tradedVolumeToken0: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair exclusively on Orderbook trades */
  tradedVolumeToken0Orderbook: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair exclusively on Swaps */
  tradedVolumeToken0Swap: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair. Includes both Swaps and Orderbook trades */
  tradedVolumeToken1: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair exclusively on Orderbook trades */
  tradedVolumeToken1Orderbook: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair exclusively on Swaps */
  tradedVolumeToken1Swap: Scalars['BigInt'];
};

export type PairDailyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PairDailyData_Filter>>>;
  dayEnd?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayEnd_lt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_lte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayNumber?: InputMaybe<Scalars['Int']>;
  dayNumber_gt?: InputMaybe<Scalars['Int']>;
  dayNumber_gte?: InputMaybe<Scalars['Int']>;
  dayNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  dayNumber_lt?: InputMaybe<Scalars['Int']>;
  dayNumber_lte?: InputMaybe<Scalars['Int']>;
  dayNumber_not?: InputMaybe<Scalars['Int']>;
  dayNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  dayStart?: InputMaybe<Scalars['BigInt']>;
  dayStart_gt?: InputMaybe<Scalars['BigInt']>;
  dayStart_gte?: InputMaybe<Scalars['BigInt']>;
  dayStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayStart_lt?: InputMaybe<Scalars['BigInt']>;
  dayStart_lte?: InputMaybe<Scalars['BigInt']>;
  dayStart_not?: InputMaybe<Scalars['BigInt']>;
  dayStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<PairDailyData_Filter>>>;
  pair?: InputMaybe<Scalars['String']>;
  pair_?: InputMaybe<Pair_Filter>;
  pair_contains?: InputMaybe<Scalars['String']>;
  pair_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_ends_with?: InputMaybe<Scalars['String']>;
  pair_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_gt?: InputMaybe<Scalars['String']>;
  pair_gte?: InputMaybe<Scalars['String']>;
  pair_in?: InputMaybe<Array<Scalars['String']>>;
  pair_lt?: InputMaybe<Scalars['String']>;
  pair_lte?: InputMaybe<Scalars['String']>;
  pair_not?: InputMaybe<Scalars['String']>;
  pair_not_contains?: InputMaybe<Scalars['String']>;
  pair_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_not_ends_with?: InputMaybe<Scalars['String']>;
  pair_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_not_in?: InputMaybe<Array<Scalars['String']>>;
  pair_not_starts_with?: InputMaybe<Scalars['String']>;
  pair_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pair_starts_with?: InputMaybe<Scalars['String']>;
  pair_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token0PriceClose?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceClose_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceHigh?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceLow?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceLow_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceOpen?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceClose?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceClose_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceHigh?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceLow?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceLow_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceOpen?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum PairDailyData_OrderBy {
  DayEnd = 'dayEnd',
  DayNumber = 'dayNumber',
  DayStart = 'dayStart',
  Id = 'id',
  Pair = 'pair',
  PairId = 'pair__id',
  PairInternalId = 'pair__internalID',
  PairToken0Price = 'pair__token0Price',
  PairToken1Price = 'pair__token1Price',
  PairTradedVolumeToken0 = 'pair__tradedVolumeToken0',
  PairTradedVolumeToken0Orderbook = 'pair__tradedVolumeToken0Orderbook',
  PairTradedVolumeToken0Swap = 'pair__tradedVolumeToken0Swap',
  PairTradedVolumeToken1 = 'pair__tradedVolumeToken1',
  PairTradedVolumeToken1Orderbook = 'pair__tradedVolumeToken1Orderbook',
  PairTradedVolumeToken1Swap = 'pair__tradedVolumeToken1Swap',
  Token0PriceClose = 'token0PriceClose',
  Token0PriceHigh = 'token0PriceHigh',
  Token0PriceLow = 'token0PriceLow',
  Token0PriceOpen = 'token0PriceOpen',
  Token1PriceClose = 'token1PriceClose',
  Token1PriceHigh = 'token1PriceHigh',
  Token1PriceLow = 'token1PriceLow',
  Token1PriceOpen = 'token1PriceOpen',
  TradedVolumeToken0 = 'tradedVolumeToken0',
  TradedVolumeToken0Orderbook = 'tradedVolumeToken0Orderbook',
  TradedVolumeToken0Swap = 'tradedVolumeToken0Swap',
  TradedVolumeToken1 = 'tradedVolumeToken1',
  TradedVolumeToken1Orderbook = 'tradedVolumeToken1Orderbook',
  TradedVolumeToken1Swap = 'tradedVolumeToken1Swap',
}

export type PairWeeklyData = {
  __typename?: 'PairWeeklyData';
  /** The ID follows this pattern: <PAIR ID>-<WEEK NUMBER>. */
  id: Scalars['ID'];
  pair: Pair;
  /** Price for token 0 at the end of the time interval */
  token0PriceClose: Scalars['BigInt'];
  /** Highest price for token 0 during the time interval */
  token0PriceHigh: Scalars['BigInt'];
  /** Lowest price for token 0 during the time interval */
  token0PriceLow: Scalars['BigInt'];
  /** Price for token 0 at the start of the time interval */
  token0PriceOpen: Scalars['BigInt'];
  /** Price for token 1 at the end of the time interval */
  token1PriceClose: Scalars['BigInt'];
  /** Highest price for token 1 during the time interval */
  token1PriceHigh: Scalars['BigInt'];
  /** Lowest price for token 1 during the time interval */
  token1PriceLow: Scalars['BigInt'];
  /** Price for token 1 at the start of the time interval */
  token1PriceOpen: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair. Includes both Swaps and Orderbook trades */
  tradedVolumeToken0: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair exclusively on Orderbook trades */
  tradedVolumeToken0Orderbook: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair exclusively on Swaps */
  tradedVolumeToken0Swap: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair. Includes both Swaps and Orderbook trades */
  tradedVolumeToken1: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair exclusively on Orderbook trades */
  tradedVolumeToken1Orderbook: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair exclusively on Swaps */
  tradedVolumeToken1Swap: Scalars['BigInt'];
  /** Timestamp of the end of the week. Timezone -> UTC */
  weekEnd: Scalars['BigInt'];
  /** Week number is the amount of weeks since the start block of Loopring 3.6 (block 11149814) */
  weekNumber: Scalars['Int'];
  /** Timestamp of the start of the week. Timezone -> UTC */
  weekStart: Scalars['BigInt'];
};

export type PairWeeklyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<PairWeeklyData_Filter>>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<PairWeeklyData_Filter>>>;
  pair?: InputMaybe<Scalars['String']>;
  pair_?: InputMaybe<Pair_Filter>;
  pair_contains?: InputMaybe<Scalars['String']>;
  pair_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_ends_with?: InputMaybe<Scalars['String']>;
  pair_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_gt?: InputMaybe<Scalars['String']>;
  pair_gte?: InputMaybe<Scalars['String']>;
  pair_in?: InputMaybe<Array<Scalars['String']>>;
  pair_lt?: InputMaybe<Scalars['String']>;
  pair_lte?: InputMaybe<Scalars['String']>;
  pair_not?: InputMaybe<Scalars['String']>;
  pair_not_contains?: InputMaybe<Scalars['String']>;
  pair_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_not_ends_with?: InputMaybe<Scalars['String']>;
  pair_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_not_in?: InputMaybe<Array<Scalars['String']>>;
  pair_not_starts_with?: InputMaybe<Scalars['String']>;
  pair_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pair_starts_with?: InputMaybe<Scalars['String']>;
  pair_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token0PriceClose?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceClose_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceHigh?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceLow?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceLow_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceOpen?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceClose?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceClose_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceHigh?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceLow?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceLow_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceOpen?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekEnd?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekEnd_lt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_lte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekNumber?: InputMaybe<Scalars['Int']>;
  weekNumber_gt?: InputMaybe<Scalars['Int']>;
  weekNumber_gte?: InputMaybe<Scalars['Int']>;
  weekNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  weekNumber_lt?: InputMaybe<Scalars['Int']>;
  weekNumber_lte?: InputMaybe<Scalars['Int']>;
  weekNumber_not?: InputMaybe<Scalars['Int']>;
  weekNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  weekStart?: InputMaybe<Scalars['BigInt']>;
  weekStart_gt?: InputMaybe<Scalars['BigInt']>;
  weekStart_gte?: InputMaybe<Scalars['BigInt']>;
  weekStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekStart_lt?: InputMaybe<Scalars['BigInt']>;
  weekStart_lte?: InputMaybe<Scalars['BigInt']>;
  weekStart_not?: InputMaybe<Scalars['BigInt']>;
  weekStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum PairWeeklyData_OrderBy {
  Id = 'id',
  Pair = 'pair',
  PairId = 'pair__id',
  PairInternalId = 'pair__internalID',
  PairToken0Price = 'pair__token0Price',
  PairToken1Price = 'pair__token1Price',
  PairTradedVolumeToken0 = 'pair__tradedVolumeToken0',
  PairTradedVolumeToken0Orderbook = 'pair__tradedVolumeToken0Orderbook',
  PairTradedVolumeToken0Swap = 'pair__tradedVolumeToken0Swap',
  PairTradedVolumeToken1 = 'pair__tradedVolumeToken1',
  PairTradedVolumeToken1Orderbook = 'pair__tradedVolumeToken1Orderbook',
  PairTradedVolumeToken1Swap = 'pair__tradedVolumeToken1Swap',
  Token0PriceClose = 'token0PriceClose',
  Token0PriceHigh = 'token0PriceHigh',
  Token0PriceLow = 'token0PriceLow',
  Token0PriceOpen = 'token0PriceOpen',
  Token1PriceClose = 'token1PriceClose',
  Token1PriceHigh = 'token1PriceHigh',
  Token1PriceLow = 'token1PriceLow',
  Token1PriceOpen = 'token1PriceOpen',
  TradedVolumeToken0 = 'tradedVolumeToken0',
  TradedVolumeToken0Orderbook = 'tradedVolumeToken0Orderbook',
  TradedVolumeToken0Swap = 'tradedVolumeToken0Swap',
  TradedVolumeToken1 = 'tradedVolumeToken1',
  TradedVolumeToken1Orderbook = 'tradedVolumeToken1Orderbook',
  TradedVolumeToken1Swap = 'tradedVolumeToken1Swap',
  WeekEnd = 'weekEnd',
  WeekNumber = 'weekNumber',
  WeekStart = 'weekStart',
}

export type Pair_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Pair_Filter>>>;
  dailyEntities_?: InputMaybe<PairDailyData_Filter>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  or?: InputMaybe<Array<InputMaybe<Pair_Filter>>>;
  token0?: InputMaybe<Scalars['String']>;
  token0Price?: InputMaybe<Scalars['BigInt']>;
  token0Price_gt?: InputMaybe<Scalars['BigInt']>;
  token0Price_gte?: InputMaybe<Scalars['BigInt']>;
  token0Price_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0Price_lt?: InputMaybe<Scalars['BigInt']>;
  token0Price_lte?: InputMaybe<Scalars['BigInt']>;
  token0Price_not?: InputMaybe<Scalars['BigInt']>;
  token0Price_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0_?: InputMaybe<Token_Filter>;
  token0_contains?: InputMaybe<Scalars['String']>;
  token0_contains_nocase?: InputMaybe<Scalars['String']>;
  token0_ends_with?: InputMaybe<Scalars['String']>;
  token0_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token0_gt?: InputMaybe<Scalars['String']>;
  token0_gte?: InputMaybe<Scalars['String']>;
  token0_in?: InputMaybe<Array<Scalars['String']>>;
  token0_lt?: InputMaybe<Scalars['String']>;
  token0_lte?: InputMaybe<Scalars['String']>;
  token0_not?: InputMaybe<Scalars['String']>;
  token0_not_contains?: InputMaybe<Scalars['String']>;
  token0_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token0_not_ends_with?: InputMaybe<Scalars['String']>;
  token0_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token0_not_in?: InputMaybe<Array<Scalars['String']>>;
  token0_not_starts_with?: InputMaybe<Scalars['String']>;
  token0_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token0_starts_with?: InputMaybe<Scalars['String']>;
  token0_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token1?: InputMaybe<Scalars['String']>;
  token1Price?: InputMaybe<Scalars['BigInt']>;
  token1Price_gt?: InputMaybe<Scalars['BigInt']>;
  token1Price_gte?: InputMaybe<Scalars['BigInt']>;
  token1Price_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1Price_lt?: InputMaybe<Scalars['BigInt']>;
  token1Price_lte?: InputMaybe<Scalars['BigInt']>;
  token1Price_not?: InputMaybe<Scalars['BigInt']>;
  token1Price_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1_?: InputMaybe<Token_Filter>;
  token1_contains?: InputMaybe<Scalars['String']>;
  token1_contains_nocase?: InputMaybe<Scalars['String']>;
  token1_ends_with?: InputMaybe<Scalars['String']>;
  token1_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token1_gt?: InputMaybe<Scalars['String']>;
  token1_gte?: InputMaybe<Scalars['String']>;
  token1_in?: InputMaybe<Array<Scalars['String']>>;
  token1_lt?: InputMaybe<Scalars['String']>;
  token1_lte?: InputMaybe<Scalars['String']>;
  token1_not?: InputMaybe<Scalars['String']>;
  token1_not_contains?: InputMaybe<Scalars['String']>;
  token1_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token1_not_ends_with?: InputMaybe<Scalars['String']>;
  token1_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token1_not_in?: InputMaybe<Array<Scalars['String']>>;
  token1_not_starts_with?: InputMaybe<Scalars['String']>;
  token1_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token1_starts_with?: InputMaybe<Scalars['String']>;
  token1_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tradedVolumeToken0?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  trades_?: InputMaybe<OrderbookTrade_Filter>;
  weeklyEntities_?: InputMaybe<PairWeeklyData_Filter>;
};

export enum Pair_OrderBy {
  DailyEntities = 'dailyEntities',
  Id = 'id',
  InternalId = 'internalID',
  Token0 = 'token0',
  Token0Price = 'token0Price',
  Token0Address = 'token0__address',
  Token0Decimals = 'token0__decimals',
  Token0Id = 'token0__id',
  Token0InternalId = 'token0__internalID',
  Token0Name = 'token0__name',
  Token0Symbol = 'token0__symbol',
  Token0TradedVolume = 'token0__tradedVolume',
  Token0TradedVolumeOrderbook = 'token0__tradedVolumeOrderbook',
  Token0TradedVolumeSwap = 'token0__tradedVolumeSwap',
  Token1 = 'token1',
  Token1Price = 'token1Price',
  Token1Address = 'token1__address',
  Token1Decimals = 'token1__decimals',
  Token1Id = 'token1__id',
  Token1InternalId = 'token1__internalID',
  Token1Name = 'token1__name',
  Token1Symbol = 'token1__symbol',
  Token1TradedVolume = 'token1__tradedVolume',
  Token1TradedVolumeOrderbook = 'token1__tradedVolumeOrderbook',
  Token1TradedVolumeSwap = 'token1__tradedVolumeSwap',
  TradedVolumeToken0 = 'tradedVolumeToken0',
  TradedVolumeToken0Orderbook = 'tradedVolumeToken0Orderbook',
  TradedVolumeToken0Swap = 'tradedVolumeToken0Swap',
  TradedVolumeToken1 = 'tradedVolumeToken1',
  TradedVolumeToken1Orderbook = 'tradedVolumeToken1Orderbook',
  TradedVolumeToken1Swap = 'tradedVolumeToken1Swap',
  Trades = 'trades',
  WeeklyEntities = 'weeklyEntities',
}

export type ProtocolAccount = Account & {
  __typename?: 'ProtocolAccount';
  address: Scalars['Bytes'];
  balances: Array<AccountTokenBalance>;
  /** L2 transaction internalID where the account was first created and linked to an address. Useful for sorting and filtering purposes */
  createdAt: Scalars['BigDecimal'];
  /** L2 transaction where the account was first created and linked to an address */
  createdAtTransaction: Transaction;
  /** ID is always 0 since there's only a single ProtocolAccount and uses the reserved id 0 */
  id: Scalars['ID'];
  /** Same as ID but expressed as a BigInt for sorting purposes */
  internalID: Scalars['BigInt'];
  /** L2 transaction internalID that last updated the account entity. Useful for sorting and filtering purposes */
  lastUpdatedAt: Scalars['BigDecimal'];
  /** L2 transaction that last updated the account entity */
  lastUpdatedAtTransaction: Transaction;
  /** L2 transactions that involved this account */
  transactions: Array<Transaction>;
};

export type ProtocolAccountBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type ProtocolAccountTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type ProtocolAccount_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  address?: InputMaybe<Scalars['Bytes']>;
  address_contains?: InputMaybe<Scalars['Bytes']>;
  address_gt?: InputMaybe<Scalars['Bytes']>;
  address_gte?: InputMaybe<Scalars['Bytes']>;
  address_in?: InputMaybe<Array<Scalars['Bytes']>>;
  address_lt?: InputMaybe<Scalars['Bytes']>;
  address_lte?: InputMaybe<Scalars['Bytes']>;
  address_not?: InputMaybe<Scalars['Bytes']>;
  address_not_contains?: InputMaybe<Scalars['Bytes']>;
  address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<ProtocolAccount_Filter>>>;
  balances_?: InputMaybe<AccountTokenBalance_Filter>;
  createdAt?: InputMaybe<Scalars['BigDecimal']>;
  createdAtTransaction?: InputMaybe<Scalars['String']>;
  createdAtTransaction_?: InputMaybe<Transaction_Filter>;
  createdAtTransaction_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_lt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_lte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  createdAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  lastUpdatedAt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAtTransaction?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_?: InputMaybe<Transaction_Filter>;
  lastUpdatedAtTransaction_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_lt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_lte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  lastUpdatedAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  or?: InputMaybe<Array<InputMaybe<ProtocolAccount_Filter>>>;
  transactions_?: InputMaybe<Transaction_Filter>;
};

export enum ProtocolAccount_OrderBy {
  Address = 'address',
  Balances = 'balances',
  CreatedAt = 'createdAt',
  CreatedAtTransaction = 'createdAtTransaction',
  CreatedAtTransactionData = 'createdAtTransaction__data',
  CreatedAtTransactionId = 'createdAtTransaction__id',
  CreatedAtTransactionInternalId = 'createdAtTransaction__internalID',
  CreatedAtTransactionTypename = 'createdAtTransaction__typename',
  Id = 'id',
  InternalId = 'internalID',
  LastUpdatedAt = 'lastUpdatedAt',
  LastUpdatedAtTransaction = 'lastUpdatedAtTransaction',
  LastUpdatedAtTransactionData = 'lastUpdatedAtTransaction__data',
  LastUpdatedAtTransactionId = 'lastUpdatedAtTransaction__id',
  LastUpdatedAtTransactionInternalId = 'lastUpdatedAtTransaction__internalID',
  LastUpdatedAtTransactionTypename = 'lastUpdatedAtTransaction__typename',
  Transactions = 'transactions',
}

export type Proxy = {
  __typename?: 'Proxy';
  /** Total amount of AccountUpdate transactions processed across all blocks */
  accountUpdateCount: Scalars['BigInt'];
  /** Total amount of Add transactions processed across all blocks */
  addCount: Scalars['BigInt'];
  /** Total amount of blocks processed */
  blockCount: Scalars['BigInt'];
  /** Current implementation is represented by a link to the current Exchange entity */
  currentImplementation?: Maybe<Exchange>;
  /** Total amount of Deposit transactions processed across all blocks */
  depositCount: Scalars['BigInt'];
  /** Proxy ID is always '0' since it's a singleton entity. */
  id: Scalars['ID'];
  /** List of all historical Exchange entities */
  implementations: Array<Exchange>;
  /** Total amount of OrderbookTrade transactions processed across all blocks */
  orderbookTradeCount: Scalars['BigInt'];
  /** Total amount of Remove transactions processed across all blocks */
  removeCount: Scalars['BigInt'];
  /** Total amount of SignatureVerification transactions processed across all blocks */
  signatureVerificationCount: Scalars['BigInt'];
  /** Total amount of Swap transactions processed across all blocks */
  swapCount: Scalars['BigInt'];
  /** Total amount of tokens supported */
  tokenCount: Scalars['BigInt'];
  /** Total amount of transactions processed across all blocks */
  transactionCount: Scalars['BigInt'];
  /** Total amount of Transfer transactions processed across all blocks */
  transferCount: Scalars['BigInt'];
  /** Total amount of unique User entities */
  userCount: Scalars['BigInt'];
  /** Total amount of Withdrawal transactions processed across all blocks */
  withdrawalCount: Scalars['BigInt'];
};

export type ProxyImplementationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Exchange_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Exchange_Filter>;
};

export type Proxy_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountUpdateCount?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_gt?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_gte?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountUpdateCount_lt?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_lte?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_not?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  addCount?: InputMaybe<Scalars['BigInt']>;
  addCount_gt?: InputMaybe<Scalars['BigInt']>;
  addCount_gte?: InputMaybe<Scalars['BigInt']>;
  addCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  addCount_lt?: InputMaybe<Scalars['BigInt']>;
  addCount_lte?: InputMaybe<Scalars['BigInt']>;
  addCount_not?: InputMaybe<Scalars['BigInt']>;
  addCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<Proxy_Filter>>>;
  blockCount?: InputMaybe<Scalars['BigInt']>;
  blockCount_gt?: InputMaybe<Scalars['BigInt']>;
  blockCount_gte?: InputMaybe<Scalars['BigInt']>;
  blockCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockCount_lt?: InputMaybe<Scalars['BigInt']>;
  blockCount_lte?: InputMaybe<Scalars['BigInt']>;
  blockCount_not?: InputMaybe<Scalars['BigInt']>;
  blockCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  currentImplementation?: InputMaybe<Scalars['String']>;
  currentImplementation_?: InputMaybe<Exchange_Filter>;
  currentImplementation_contains?: InputMaybe<Scalars['String']>;
  currentImplementation_contains_nocase?: InputMaybe<Scalars['String']>;
  currentImplementation_ends_with?: InputMaybe<Scalars['String']>;
  currentImplementation_ends_with_nocase?: InputMaybe<Scalars['String']>;
  currentImplementation_gt?: InputMaybe<Scalars['String']>;
  currentImplementation_gte?: InputMaybe<Scalars['String']>;
  currentImplementation_in?: InputMaybe<Array<Scalars['String']>>;
  currentImplementation_lt?: InputMaybe<Scalars['String']>;
  currentImplementation_lte?: InputMaybe<Scalars['String']>;
  currentImplementation_not?: InputMaybe<Scalars['String']>;
  currentImplementation_not_contains?: InputMaybe<Scalars['String']>;
  currentImplementation_not_contains_nocase?: InputMaybe<Scalars['String']>;
  currentImplementation_not_ends_with?: InputMaybe<Scalars['String']>;
  currentImplementation_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  currentImplementation_not_in?: InputMaybe<Array<Scalars['String']>>;
  currentImplementation_not_starts_with?: InputMaybe<Scalars['String']>;
  currentImplementation_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  currentImplementation_starts_with?: InputMaybe<Scalars['String']>;
  currentImplementation_starts_with_nocase?: InputMaybe<Scalars['String']>;
  depositCount?: InputMaybe<Scalars['BigInt']>;
  depositCount_gt?: InputMaybe<Scalars['BigInt']>;
  depositCount_gte?: InputMaybe<Scalars['BigInt']>;
  depositCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  depositCount_lt?: InputMaybe<Scalars['BigInt']>;
  depositCount_lte?: InputMaybe<Scalars['BigInt']>;
  depositCount_not?: InputMaybe<Scalars['BigInt']>;
  depositCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  implementations_?: InputMaybe<Exchange_Filter>;
  or?: InputMaybe<Array<InputMaybe<Proxy_Filter>>>;
  orderbookTradeCount?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_gt?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_gte?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderbookTradeCount_lt?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_lte?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_not?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  removeCount?: InputMaybe<Scalars['BigInt']>;
  removeCount_gt?: InputMaybe<Scalars['BigInt']>;
  removeCount_gte?: InputMaybe<Scalars['BigInt']>;
  removeCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  removeCount_lt?: InputMaybe<Scalars['BigInt']>;
  removeCount_lte?: InputMaybe<Scalars['BigInt']>;
  removeCount_not?: InputMaybe<Scalars['BigInt']>;
  removeCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  signatureVerificationCount?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_gt?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_gte?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  signatureVerificationCount_lt?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_lte?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_not?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  swapCount?: InputMaybe<Scalars['BigInt']>;
  swapCount_gt?: InputMaybe<Scalars['BigInt']>;
  swapCount_gte?: InputMaybe<Scalars['BigInt']>;
  swapCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  swapCount_lt?: InputMaybe<Scalars['BigInt']>;
  swapCount_lte?: InputMaybe<Scalars['BigInt']>;
  swapCount_not?: InputMaybe<Scalars['BigInt']>;
  swapCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenCount?: InputMaybe<Scalars['BigInt']>;
  tokenCount_gt?: InputMaybe<Scalars['BigInt']>;
  tokenCount_gte?: InputMaybe<Scalars['BigInt']>;
  tokenCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenCount_lt?: InputMaybe<Scalars['BigInt']>;
  tokenCount_lte?: InputMaybe<Scalars['BigInt']>;
  tokenCount_not?: InputMaybe<Scalars['BigInt']>;
  tokenCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionCount?: InputMaybe<Scalars['BigInt']>;
  transactionCount_gt?: InputMaybe<Scalars['BigInt']>;
  transactionCount_gte?: InputMaybe<Scalars['BigInt']>;
  transactionCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionCount_lt?: InputMaybe<Scalars['BigInt']>;
  transactionCount_lte?: InputMaybe<Scalars['BigInt']>;
  transactionCount_not?: InputMaybe<Scalars['BigInt']>;
  transactionCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transferCount?: InputMaybe<Scalars['BigInt']>;
  transferCount_gt?: InputMaybe<Scalars['BigInt']>;
  transferCount_gte?: InputMaybe<Scalars['BigInt']>;
  transferCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transferCount_lt?: InputMaybe<Scalars['BigInt']>;
  transferCount_lte?: InputMaybe<Scalars['BigInt']>;
  transferCount_not?: InputMaybe<Scalars['BigInt']>;
  transferCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  userCount?: InputMaybe<Scalars['BigInt']>;
  userCount_gt?: InputMaybe<Scalars['BigInt']>;
  userCount_gte?: InputMaybe<Scalars['BigInt']>;
  userCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  userCount_lt?: InputMaybe<Scalars['BigInt']>;
  userCount_lte?: InputMaybe<Scalars['BigInt']>;
  userCount_not?: InputMaybe<Scalars['BigInt']>;
  userCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  withdrawalCount?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_gt?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_gte?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  withdrawalCount_lt?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_lte?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_not?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum Proxy_OrderBy {
  AccountUpdateCount = 'accountUpdateCount',
  AddCount = 'addCount',
  BlockCount = 'blockCount',
  CurrentImplementation = 'currentImplementation',
  CurrentImplementationId = 'currentImplementation__id',
  DepositCount = 'depositCount',
  Id = 'id',
  Implementations = 'implementations',
  OrderbookTradeCount = 'orderbookTradeCount',
  RemoveCount = 'removeCount',
  SignatureVerificationCount = 'signatureVerificationCount',
  SwapCount = 'swapCount',
  TokenCount = 'tokenCount',
  TransactionCount = 'transactionCount',
  TransferCount = 'transferCount',
  UserCount = 'userCount',
  WithdrawalCount = 'withdrawalCount',
}

export type Query = {
  __typename?: 'Query';
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
  account?: Maybe<Account>;
  accountTokenBalance?: Maybe<AccountTokenBalance>;
  accountTokenBalanceDailyData?: Maybe<AccountTokenBalanceDailyData>;
  accountTokenBalanceDailyDatas: Array<AccountTokenBalanceDailyData>;
  accountTokenBalanceWeeklyData?: Maybe<AccountTokenBalanceWeeklyData>;
  accountTokenBalanceWeeklyDatas: Array<AccountTokenBalanceWeeklyData>;
  accountTokenBalances: Array<AccountTokenBalance>;
  accountUpdate?: Maybe<AccountUpdate>;
  accountUpdates: Array<AccountUpdate>;
  accounts: Array<Account>;
  batchSpotTrade?: Maybe<BatchSpotTrade>;
  batchSpotTrades: Array<BatchSpotTrade>;
  block?: Maybe<Block>;
  blocks: Array<Block>;
  deposit?: Maybe<Deposit>;
  deposits: Array<Deposit>;
  exchange?: Maybe<Exchange>;
  exchanges: Array<Exchange>;
  orderbookTrade?: Maybe<OrderbookTrade>;
  orderbookTrades: Array<OrderbookTrade>;
  pair?: Maybe<Pair>;
  pairDailyData?: Maybe<PairDailyData>;
  pairDailyDatas: Array<PairDailyData>;
  pairWeeklyData?: Maybe<PairWeeklyData>;
  pairWeeklyDatas: Array<PairWeeklyData>;
  pairs: Array<Pair>;
  protocolAccount?: Maybe<ProtocolAccount>;
  protocolAccounts: Array<ProtocolAccount>;
  proxies: Array<Proxy>;
  proxy?: Maybe<Proxy>;
  signatureVerification?: Maybe<SignatureVerification>;
  signatureVerifications: Array<SignatureVerification>;
  token?: Maybe<Token>;
  tokenDailyData?: Maybe<TokenDailyData>;
  tokenDailyDatas: Array<TokenDailyData>;
  tokenWeeklyData?: Maybe<TokenWeeklyData>;
  tokenWeeklyDatas: Array<TokenWeeklyData>;
  tokens: Array<Token>;
  transaction?: Maybe<Transaction>;
  transactions: Array<Transaction>;
  transfer?: Maybe<Transfer>;
  transfers: Array<Transfer>;
  user?: Maybe<User>;
  users: Array<User>;
  withdrawal?: Maybe<Withdrawal>;
  withdrawals: Array<Withdrawal>;
};

export type Query_MetaArgs = {
  block?: InputMaybe<Block_Height>;
};

export type QueryAccountArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountTokenBalanceArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountTokenBalanceDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountTokenBalanceDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalanceDailyData_Filter>;
};

export type QueryAccountTokenBalanceWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountTokenBalanceWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalanceWeeklyData_Filter>;
};

export type QueryAccountTokenBalancesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type QueryAccountUpdateArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountUpdatesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountUpdate_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountUpdate_Filter>;
};

export type QueryAccountsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Account_Filter>;
};

export type QueryBatchSpotTradeArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryBatchSpotTradesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<BatchSpotTrade_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<BatchSpotTrade_Filter>;
};

export type QueryBlockArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryBlocksArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Block_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Block_Filter>;
};

export type QueryDepositArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryDepositsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Deposit_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Deposit_Filter>;
};

export type QueryExchangeArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryExchangesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Exchange_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Exchange_Filter>;
};

export type QueryOrderbookTradeArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryOrderbookTradesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OrderbookTrade_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<OrderbookTrade_Filter>;
};

export type QueryPairArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryPairDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryPairDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PairDailyData_Filter>;
};

export type QueryPairWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryPairWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PairWeeklyData_Filter>;
};

export type QueryPairsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Pair_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Pair_Filter>;
};

export type QueryProtocolAccountArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryProtocolAccountsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProtocolAccount_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<ProtocolAccount_Filter>;
};

export type QueryProxiesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Proxy_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Proxy_Filter>;
};

export type QueryProxyArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerySignatureVerificationArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerySignatureVerificationsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SignatureVerification_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SignatureVerification_Filter>;
};

export type QueryTokenArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTokenDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTokenDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenDailyData_Filter>;
};

export type QueryTokenWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTokenWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenWeeklyData_Filter>;
};

export type QueryTokensArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Token_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Token_Filter>;
};

export type QueryTransactionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTransactionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Transaction_Filter>;
};

export type QueryTransferArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTransfersArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transfer_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Transfer_Filter>;
};

export type QueryUserArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryUsersArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<User_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<User_Filter>;
};

export type QueryWithdrawalArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryWithdrawalsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Withdrawal_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Withdrawal_Filter>;
};

export type SignatureVerification = Transaction & {
  __typename?: 'SignatureVerification';
  /** Account entity updated in this transaction */
  account: Account;
  /** [RAW L2 DATA] Account ID of the pool account updated */
  accountID: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  block: Block;
  data: Scalars['String'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] Address of the account updated */
  owner: Scalars['String'];
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
  /** [RAW L2 DATA] Signature verification data */
  verificationData: Scalars['String'];
};

export type SignatureVerificationAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type SignatureVerificationTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type SignatureVerification_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountID?: InputMaybe<Scalars['Int']>;
  accountID_gt?: InputMaybe<Scalars['Int']>;
  accountID_gte?: InputMaybe<Scalars['Int']>;
  accountID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountID_lt?: InputMaybe<Scalars['Int']>;
  accountID_lte?: InputMaybe<Scalars['Int']>;
  accountID_not?: InputMaybe<Scalars['Int']>;
  accountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  and?: InputMaybe<Array<InputMaybe<SignatureVerification_Filter>>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  or?: InputMaybe<Array<InputMaybe<SignatureVerification_Filter>>>;
  owner?: InputMaybe<Scalars['String']>;
  owner_contains?: InputMaybe<Scalars['String']>;
  owner_contains_nocase?: InputMaybe<Scalars['String']>;
  owner_ends_with?: InputMaybe<Scalars['String']>;
  owner_ends_with_nocase?: InputMaybe<Scalars['String']>;
  owner_gt?: InputMaybe<Scalars['String']>;
  owner_gte?: InputMaybe<Scalars['String']>;
  owner_in?: InputMaybe<Array<Scalars['String']>>;
  owner_lt?: InputMaybe<Scalars['String']>;
  owner_lte?: InputMaybe<Scalars['String']>;
  owner_not?: InputMaybe<Scalars['String']>;
  owner_not_contains?: InputMaybe<Scalars['String']>;
  owner_not_contains_nocase?: InputMaybe<Scalars['String']>;
  owner_not_ends_with?: InputMaybe<Scalars['String']>;
  owner_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  owner_not_in?: InputMaybe<Array<Scalars['String']>>;
  owner_not_starts_with?: InputMaybe<Scalars['String']>;
  owner_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  owner_starts_with?: InputMaybe<Scalars['String']>;
  owner_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
  verificationData?: InputMaybe<Scalars['String']>;
  verificationData_contains?: InputMaybe<Scalars['String']>;
  verificationData_contains_nocase?: InputMaybe<Scalars['String']>;
  verificationData_ends_with?: InputMaybe<Scalars['String']>;
  verificationData_ends_with_nocase?: InputMaybe<Scalars['String']>;
  verificationData_gt?: InputMaybe<Scalars['String']>;
  verificationData_gte?: InputMaybe<Scalars['String']>;
  verificationData_in?: InputMaybe<Array<Scalars['String']>>;
  verificationData_lt?: InputMaybe<Scalars['String']>;
  verificationData_lte?: InputMaybe<Scalars['String']>;
  verificationData_not?: InputMaybe<Scalars['String']>;
  verificationData_not_contains?: InputMaybe<Scalars['String']>;
  verificationData_not_contains_nocase?: InputMaybe<Scalars['String']>;
  verificationData_not_ends_with?: InputMaybe<Scalars['String']>;
  verificationData_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  verificationData_not_in?: InputMaybe<Array<Scalars['String']>>;
  verificationData_not_starts_with?: InputMaybe<Scalars['String']>;
  verificationData_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  verificationData_starts_with?: InputMaybe<Scalars['String']>;
  verificationData_starts_with_nocase?: InputMaybe<Scalars['String']>;
};

export enum SignatureVerification_OrderBy {
  Account = 'account',
  AccountId = 'accountID',
  AccountAddress = 'account__address',
  AccountCreatedAt = 'account__createdAt',
  AccountId = 'account__id',
  AccountInternalId = 'account__internalID',
  AccountLastUpdatedAt = 'account__lastUpdatedAt',
  Accounts = 'accounts',
  Block = 'block',
  BlockAccountUpdateCount = 'block__accountUpdateCount',
  BlockAccountUpdateSize = 'block__accountUpdateSize',
  BlockAddCount = 'block__addCount',
  BlockAuxiliaryData = 'block__auxiliaryData',
  BlockBlockHash = 'block__blockHash',
  BlockBlockSize = 'block__blockSize',
  BlockBlockType = 'block__blockType',
  BlockBlockVersion = 'block__blockVersion',
  BlockData = 'block__data',
  BlockDepositCount = 'block__depositCount',
  BlockDepositSize = 'block__depositSize',
  BlockExchange = 'block__exchange',
  BlockGasLimit = 'block__gasLimit',
  BlockGasPrice = 'block__gasPrice',
  BlockHeight = 'block__height',
  BlockId = 'block__id',
  BlockInternalId = 'block__internalID',
  BlockNumConditionalTransactions = 'block__numConditionalTransactions',
  BlockOffchainData = 'block__offchainData',
  BlockOperatorAccountId = 'block__operatorAccountID',
  BlockOrderbookTradeCount = 'block__orderbookTradeCount',
  BlockProtocolFeeBips = 'block__protocolFeeBips',
  BlockRemoveCount = 'block__removeCount',
  BlockSignatureVerificationCount = 'block__signatureVerificationCount',
  BlockStoreBlockInfoOnchain = 'block__storeBlockInfoOnchain',
  BlockSwapCount = 'block__swapCount',
  BlockTimestamp = 'block__timestamp',
  BlockTransactionCount = 'block__transactionCount',
  BlockTransferCount = 'block__transferCount',
  BlockTxHash = 'block__txHash',
  BlockWithdrawSize = 'block__withdrawSize',
  BlockWithdrawalCount = 'block__withdrawalCount',
  Data = 'data',
  Id = 'id',
  InternalId = 'internalID',
  Owner = 'owner',
  TokenBalances = 'tokenBalances',
  Typename = 'typename',
  VerificationData = 'verificationData',
}

export type Subscription = {
  __typename?: 'Subscription';
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
  account?: Maybe<Account>;
  accountTokenBalance?: Maybe<AccountTokenBalance>;
  accountTokenBalanceDailyData?: Maybe<AccountTokenBalanceDailyData>;
  accountTokenBalanceDailyDatas: Array<AccountTokenBalanceDailyData>;
  accountTokenBalanceWeeklyData?: Maybe<AccountTokenBalanceWeeklyData>;
  accountTokenBalanceWeeklyDatas: Array<AccountTokenBalanceWeeklyData>;
  accountTokenBalances: Array<AccountTokenBalance>;
  accountUpdate?: Maybe<AccountUpdate>;
  accountUpdates: Array<AccountUpdate>;
  accounts: Array<Account>;
  batchSpotTrade?: Maybe<BatchSpotTrade>;
  batchSpotTrades: Array<BatchSpotTrade>;
  block?: Maybe<Block>;
  blocks: Array<Block>;
  deposit?: Maybe<Deposit>;
  deposits: Array<Deposit>;
  exchange?: Maybe<Exchange>;
  exchanges: Array<Exchange>;
  orderbookTrade?: Maybe<OrderbookTrade>;
  orderbookTrades: Array<OrderbookTrade>;
  pair?: Maybe<Pair>;
  pairDailyData?: Maybe<PairDailyData>;
  pairDailyDatas: Array<PairDailyData>;
  pairWeeklyData?: Maybe<PairWeeklyData>;
  pairWeeklyDatas: Array<PairWeeklyData>;
  pairs: Array<Pair>;
  protocolAccount?: Maybe<ProtocolAccount>;
  protocolAccounts: Array<ProtocolAccount>;
  proxies: Array<Proxy>;
  proxy?: Maybe<Proxy>;
  signatureVerification?: Maybe<SignatureVerification>;
  signatureVerifications: Array<SignatureVerification>;
  token?: Maybe<Token>;
  tokenDailyData?: Maybe<TokenDailyData>;
  tokenDailyDatas: Array<TokenDailyData>;
  tokenWeeklyData?: Maybe<TokenWeeklyData>;
  tokenWeeklyDatas: Array<TokenWeeklyData>;
  tokens: Array<Token>;
  transaction?: Maybe<Transaction>;
  transactions: Array<Transaction>;
  transfer?: Maybe<Transfer>;
  transfers: Array<Transfer>;
  user?: Maybe<User>;
  users: Array<User>;
  withdrawal?: Maybe<Withdrawal>;
  withdrawals: Array<Withdrawal>;
};

export type Subscription_MetaArgs = {
  block?: InputMaybe<Block_Height>;
};

export type SubscriptionAccountArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountTokenBalanceArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountTokenBalanceDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountTokenBalanceDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalanceDailyData_Filter>;
};

export type SubscriptionAccountTokenBalanceWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountTokenBalanceWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalanceWeeklyData_Filter>;
};

export type SubscriptionAccountTokenBalancesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type SubscriptionAccountUpdateArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountUpdatesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountUpdate_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountUpdate_Filter>;
};

export type SubscriptionAccountsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Account_Filter>;
};

export type SubscriptionBatchSpotTradeArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionBatchSpotTradesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<BatchSpotTrade_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<BatchSpotTrade_Filter>;
};

export type SubscriptionBlockArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionBlocksArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Block_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Block_Filter>;
};

export type SubscriptionDepositArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionDepositsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Deposit_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Deposit_Filter>;
};

export type SubscriptionExchangeArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionExchangesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Exchange_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Exchange_Filter>;
};

export type SubscriptionOrderbookTradeArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionOrderbookTradesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OrderbookTrade_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<OrderbookTrade_Filter>;
};

export type SubscriptionPairArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionPairDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionPairDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PairDailyData_Filter>;
};

export type SubscriptionPairWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionPairWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PairWeeklyData_Filter>;
};

export type SubscriptionPairsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Pair_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Pair_Filter>;
};

export type SubscriptionProtocolAccountArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionProtocolAccountsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProtocolAccount_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<ProtocolAccount_Filter>;
};

export type SubscriptionProxiesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Proxy_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Proxy_Filter>;
};

export type SubscriptionProxyArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionSignatureVerificationArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionSignatureVerificationsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SignatureVerification_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SignatureVerification_Filter>;
};

export type SubscriptionTokenArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTokenDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTokenDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenDailyData_Filter>;
};

export type SubscriptionTokenWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTokenWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenWeeklyData_Filter>;
};

export type SubscriptionTokensArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Token_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Token_Filter>;
};

export type SubscriptionTransactionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTransactionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Transaction_Filter>;
};

export type SubscriptionTransferArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTransfersArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transfer_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Transfer_Filter>;
};

export type SubscriptionUserArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionUsersArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<User_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<User_Filter>;
};

export type SubscriptionWithdrawalArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionWithdrawalsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Withdrawal_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Withdrawal_Filter>;
};

export type Token = {
  __typename?: 'Token';
  /** Address of the token within the Ethereum network */
  address: Scalars['Bytes'];
  dailyEntities: Array<TokenDailyData>;
  decimals: Scalars['Int'];
  /** Exchange active when the token was registered */
  exchange: Exchange;
  /** Internal ID of the token within Loopring */
  id: Scalars['ID'];
  /** Internal ID of the token within loopring expressed as a number for ordering */
  internalID: Scalars['BigInt'];
  name: Scalars['String'];
  symbol: Scalars['String'];
  /** Total traded volume for this token across all token pairs. Denominated in it's own currency */
  tradedVolume: Scalars['BigInt'];
  /** Total traded volume for this token across all token pairs. Denominated in it's own currency */
  tradedVolumeOrderbook: Scalars['BigInt'];
  /** Total traded volume for this token across all token pairs. Denominated in it's own currency */
  tradedVolumeSwap: Scalars['BigInt'];
  weeklyEntities: Array<TokenWeeklyData>;
};

export type TokenDailyEntitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TokenDailyData_Filter>;
};

export type TokenWeeklyEntitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TokenWeeklyData_Filter>;
};

export type TokenDailyData = {
  __typename?: 'TokenDailyData';
  /** Timestamp of the end of the day. Timezone -> UTC */
  dayEnd: Scalars['BigInt'];
  /** Day number is the amount of days since the start block of Loopring 3.6 (block 11149814) */
  dayNumber: Scalars['Int'];
  /** Timestamp of the start of the day. Timezone -> UTC */
  dayStart: Scalars['BigInt'];
  /** The ID follows this pattern: <TOKEN ID>-<DAY NUMBER>. */
  id: Scalars['ID'];
  token: Token;
  /** Volume traded for the token. Includes both Swaps and Orderbook trades */
  tradedVolume: Scalars['BigInt'];
  /** Volume traded for the token exclusively on Orderbook trades */
  tradedVolumeOrderbook: Scalars['BigInt'];
  /** Volume traded for the token exclusively on Swaps */
  tradedVolumeSwap: Scalars['BigInt'];
};

export type TokenDailyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenDailyData_Filter>>>;
  dayEnd?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayEnd_lt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_lte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayNumber?: InputMaybe<Scalars['Int']>;
  dayNumber_gt?: InputMaybe<Scalars['Int']>;
  dayNumber_gte?: InputMaybe<Scalars['Int']>;
  dayNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  dayNumber_lt?: InputMaybe<Scalars['Int']>;
  dayNumber_lte?: InputMaybe<Scalars['Int']>;
  dayNumber_not?: InputMaybe<Scalars['Int']>;
  dayNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  dayStart?: InputMaybe<Scalars['BigInt']>;
  dayStart_gt?: InputMaybe<Scalars['BigInt']>;
  dayStart_gte?: InputMaybe<Scalars['BigInt']>;
  dayStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayStart_lt?: InputMaybe<Scalars['BigInt']>;
  dayStart_lte?: InputMaybe<Scalars['BigInt']>;
  dayStart_not?: InputMaybe<Scalars['BigInt']>;
  dayStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<TokenDailyData_Filter>>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tradedVolume?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeOrderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum TokenDailyData_OrderBy {
  DayEnd = 'dayEnd',
  DayNumber = 'dayNumber',
  DayStart = 'dayStart',
  Id = 'id',
  Token = 'token',
  TokenAddress = 'token__address',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenInternalId = 'token__internalID',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenTradedVolume = 'token__tradedVolume',
  TokenTradedVolumeOrderbook = 'token__tradedVolumeOrderbook',
  TokenTradedVolumeSwap = 'token__tradedVolumeSwap',
  TradedVolume = 'tradedVolume',
  TradedVolumeOrderbook = 'tradedVolumeOrderbook',
  TradedVolumeSwap = 'tradedVolumeSwap',
}

export type TokenWeeklyData = {
  __typename?: 'TokenWeeklyData';
  /** The ID follows this pattern: <TOKEN ID>-<WEEK NUMBER>. */
  id: Scalars['ID'];
  token: Token;
  /** Volume traded for the token. Includes both Swaps and Orderbook trades */
  tradedVolume: Scalars['BigInt'];
  /** Volume traded for the token exclusively on Orderbook trades */
  tradedVolumeOrderbook: Scalars['BigInt'];
  /** Volume traded for the token exclusively on Swaps */
  tradedVolumeSwap: Scalars['BigInt'];
  /** Timestamp of the end of the week. Timezone -> UTC */
  weekEnd: Scalars['BigInt'];
  /** Week number is the amount of weeks since the start block of Loopring 3.6 (block 11149814) */
  weekNumber: Scalars['Int'];
  /** Timestamp of the start of the week. Timezone -> UTC */
  weekStart: Scalars['BigInt'];
};

export type TokenWeeklyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenWeeklyData_Filter>>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<TokenWeeklyData_Filter>>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tradedVolume?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeOrderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekEnd?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekEnd_lt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_lte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekNumber?: InputMaybe<Scalars['Int']>;
  weekNumber_gt?: InputMaybe<Scalars['Int']>;
  weekNumber_gte?: InputMaybe<Scalars['Int']>;
  weekNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  weekNumber_lt?: InputMaybe<Scalars['Int']>;
  weekNumber_lte?: InputMaybe<Scalars['Int']>;
  weekNumber_not?: InputMaybe<Scalars['Int']>;
  weekNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  weekStart?: InputMaybe<Scalars['BigInt']>;
  weekStart_gt?: InputMaybe<Scalars['BigInt']>;
  weekStart_gte?: InputMaybe<Scalars['BigInt']>;
  weekStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekStart_lt?: InputMaybe<Scalars['BigInt']>;
  weekStart_lte?: InputMaybe<Scalars['BigInt']>;
  weekStart_not?: InputMaybe<Scalars['BigInt']>;
  weekStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum TokenWeeklyData_OrderBy {
  Id = 'id',
  Token = 'token',
  TokenAddress = 'token__address',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenInternalId = 'token__internalID',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenTradedVolume = 'token__tradedVolume',
  TokenTradedVolumeOrderbook = 'token__tradedVolumeOrderbook',
  TokenTradedVolumeSwap = 'token__tradedVolumeSwap',
  TradedVolume = 'tradedVolume',
  TradedVolumeOrderbook = 'tradedVolumeOrderbook',
  TradedVolumeSwap = 'tradedVolumeSwap',
  WeekEnd = 'weekEnd',
  WeekNumber = 'weekNumber',
  WeekStart = 'weekStart',
}

export type Token_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  address?: InputMaybe<Scalars['Bytes']>;
  address_contains?: InputMaybe<Scalars['Bytes']>;
  address_gt?: InputMaybe<Scalars['Bytes']>;
  address_gte?: InputMaybe<Scalars['Bytes']>;
  address_in?: InputMaybe<Array<Scalars['Bytes']>>;
  address_lt?: InputMaybe<Scalars['Bytes']>;
  address_lte?: InputMaybe<Scalars['Bytes']>;
  address_not?: InputMaybe<Scalars['Bytes']>;
  address_not_contains?: InputMaybe<Scalars['Bytes']>;
  address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<Token_Filter>>>;
  dailyEntities_?: InputMaybe<TokenDailyData_Filter>;
  decimals?: InputMaybe<Scalars['Int']>;
  decimals_gt?: InputMaybe<Scalars['Int']>;
  decimals_gte?: InputMaybe<Scalars['Int']>;
  decimals_in?: InputMaybe<Array<Scalars['Int']>>;
  decimals_lt?: InputMaybe<Scalars['Int']>;
  decimals_lte?: InputMaybe<Scalars['Int']>;
  decimals_not?: InputMaybe<Scalars['Int']>;
  decimals_not_in?: InputMaybe<Array<Scalars['Int']>>;
  exchange?: InputMaybe<Scalars['String']>;
  exchange_?: InputMaybe<Exchange_Filter>;
  exchange_contains?: InputMaybe<Scalars['String']>;
  exchange_contains_nocase?: InputMaybe<Scalars['String']>;
  exchange_ends_with?: InputMaybe<Scalars['String']>;
  exchange_ends_with_nocase?: InputMaybe<Scalars['String']>;
  exchange_gt?: InputMaybe<Scalars['String']>;
  exchange_gte?: InputMaybe<Scalars['String']>;
  exchange_in?: InputMaybe<Array<Scalars['String']>>;
  exchange_lt?: InputMaybe<Scalars['String']>;
  exchange_lte?: InputMaybe<Scalars['String']>;
  exchange_not?: InputMaybe<Scalars['String']>;
  exchange_not_contains?: InputMaybe<Scalars['String']>;
  exchange_not_contains_nocase?: InputMaybe<Scalars['String']>;
  exchange_not_ends_with?: InputMaybe<Scalars['String']>;
  exchange_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  exchange_not_in?: InputMaybe<Array<Scalars['String']>>;
  exchange_not_starts_with?: InputMaybe<Scalars['String']>;
  exchange_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  exchange_starts_with?: InputMaybe<Scalars['String']>;
  exchange_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<Token_Filter>>>;
  symbol?: InputMaybe<Scalars['String']>;
  symbol_contains?: InputMaybe<Scalars['String']>;
  symbol_contains_nocase?: InputMaybe<Scalars['String']>;
  symbol_ends_with?: InputMaybe<Scalars['String']>;
  symbol_ends_with_nocase?: InputMaybe<Scalars['String']>;
  symbol_gt?: InputMaybe<Scalars['String']>;
  symbol_gte?: InputMaybe<Scalars['String']>;
  symbol_in?: InputMaybe<Array<Scalars['String']>>;
  symbol_lt?: InputMaybe<Scalars['String']>;
  symbol_lte?: InputMaybe<Scalars['String']>;
  symbol_not?: InputMaybe<Scalars['String']>;
  symbol_not_contains?: InputMaybe<Scalars['String']>;
  symbol_not_contains_nocase?: InputMaybe<Scalars['String']>;
  symbol_not_ends_with?: InputMaybe<Scalars['String']>;
  symbol_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  symbol_not_in?: InputMaybe<Array<Scalars['String']>>;
  symbol_not_starts_with?: InputMaybe<Scalars['String']>;
  symbol_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  symbol_starts_with?: InputMaybe<Scalars['String']>;
  symbol_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tradedVolume?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeOrderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weeklyEntities_?: InputMaybe<TokenWeeklyData_Filter>;
};

export enum Token_OrderBy {
  Address = 'address',
  DailyEntities = 'dailyEntities',
  Decimals = 'decimals',
  Exchange = 'exchange',
  ExchangeId = 'exchange__id',
  Id = 'id',
  InternalId = 'internalID',
  Name = 'name',
  Symbol = 'symbol',
  TradedVolume = 'tradedVolume',
  TradedVolumeOrderbook = 'tradedVolumeOrderbook',
  TradedVolumeSwap = 'tradedVolumeSwap',
  WeeklyEntities = 'weeklyEntities',
}

export type Transaction = {
  accounts?: Maybe<Array<Account>>;
  /** Link to the Block entity where this Transaction took place */
  block: Block;
  /** Hex string representation of the encoded L2 data for this Transaction */
  data: Scalars['String'];
  /** All transactions IDs follow the same pattern: <BLOCK ID>-<TX INDEX> */
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type TransactionAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type TransactionTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export enum TransactionType {
  AccountUpdate = 'AccountUpdate',
  BatchSpotTrade = 'BatchSpotTrade',
  Deposit = 'Deposit',
  OrderbookTrade = 'OrderbookTrade',
  SignatureVerification = 'SignatureVerification',
  Transfer = 'Transfer',
  Withdrawal = 'Withdrawal',
}

export type Transaction_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  and?: InputMaybe<Array<InputMaybe<Transaction_Filter>>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  or?: InputMaybe<Array<InputMaybe<Transaction_Filter>>>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum Transaction_OrderBy {
  Accounts = 'accounts',
  Block = 'block',
  BlockAccountUpdateCount = 'block__accountUpdateCount',
  BlockAccountUpdateSize = 'block__accountUpdateSize',
  BlockAddCount = 'block__addCount',
  BlockAuxiliaryData = 'block__auxiliaryData',
  BlockBlockHash = 'block__blockHash',
  BlockBlockSize = 'block__blockSize',
  BlockBlockType = 'block__blockType',
  BlockBlockVersion = 'block__blockVersion',
  BlockData = 'block__data',
  BlockDepositCount = 'block__depositCount',
  BlockDepositSize = 'block__depositSize',
  BlockExchange = 'block__exchange',
  BlockGasLimit = 'block__gasLimit',
  BlockGasPrice = 'block__gasPrice',
  BlockHeight = 'block__height',
  BlockId = 'block__id',
  BlockInternalId = 'block__internalID',
  BlockNumConditionalTransactions = 'block__numConditionalTransactions',
  BlockOffchainData = 'block__offchainData',
  BlockOperatorAccountId = 'block__operatorAccountID',
  BlockOrderbookTradeCount = 'block__orderbookTradeCount',
  BlockProtocolFeeBips = 'block__protocolFeeBips',
  BlockRemoveCount = 'block__removeCount',
  BlockSignatureVerificationCount = 'block__signatureVerificationCount',
  BlockStoreBlockInfoOnchain = 'block__storeBlockInfoOnchain',
  BlockSwapCount = 'block__swapCount',
  BlockTimestamp = 'block__timestamp',
  BlockTransactionCount = 'block__transactionCount',
  BlockTransferCount = 'block__transferCount',
  BlockTxHash = 'block__txHash',
  BlockWithdrawSize = 'block__withdrawSize',
  BlockWithdrawalCount = 'block__withdrawalCount',
  Data = 'data',
  Id = 'id',
  InternalId = 'internalID',
  TokenBalances = 'tokenBalances',
  Typename = 'typename',
}

export type Transfer = Transaction & {
  __typename?: 'Transfer';
  /** [RAW L2 DATA] Account ID for the account that sent the tokens */
  accountFromID: Scalars['Int'];
  /** [RAW L2 DATA] Account ID for the account that received the tokens */
  accountToID: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  /** [RAW L2 DATA] Amount transfered */
  amount: Scalars['BigInt'];
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Fee amount paid */
  fee: Scalars['BigInt'];
  /** Token entity with information about the token used to pay the operator fees */
  feeToken: Token;
  /** [RAW L2 DATA] Token ID of token used to pay the operator fees */
  feeTokenID: Scalars['Int'];
  /** [RAW L2 DATA] Address string of the account that sent the tokens */
  from: Scalars['String'];
  /** Account entity that sent the tokens */
  fromAccount: Account;
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] StorageID */
  storageID: Scalars['Int'];
  /** [RAW L2 DATA] Address string of the account that received the tokens */
  to: Scalars['String'];
  /** Account entity that received the tokens */
  toAccount: Account;
  /** [RAW L2 DATA] Token ID of the token transfered. Mainly used for NFT transfers */
  toTokenID: Scalars['Int'];
  /** Token entity with information about the token transfered */
  token: Token;
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of the token transfered */
  tokenID: Scalars['Int'];
  /** [RAW L2 DATA] Transfer type */
  type: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type TransferAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type TransferTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type Transfer_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountFromID?: InputMaybe<Scalars['Int']>;
  accountFromID_gt?: InputMaybe<Scalars['Int']>;
  accountFromID_gte?: InputMaybe<Scalars['Int']>;
  accountFromID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountFromID_lt?: InputMaybe<Scalars['Int']>;
  accountFromID_lte?: InputMaybe<Scalars['Int']>;
  accountFromID_not?: InputMaybe<Scalars['Int']>;
  accountFromID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountToID?: InputMaybe<Scalars['Int']>;
  accountToID_gt?: InputMaybe<Scalars['Int']>;
  accountToID_gte?: InputMaybe<Scalars['Int']>;
  accountToID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountToID_lt?: InputMaybe<Scalars['Int']>;
  accountToID_lte?: InputMaybe<Scalars['Int']>;
  accountToID_not?: InputMaybe<Scalars['Int']>;
  accountToID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<Transfer_Filter>>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  from?: InputMaybe<Scalars['String']>;
  fromAccount?: InputMaybe<Scalars['String']>;
  fromAccount_?: InputMaybe<Account_Filter>;
  fromAccount_contains?: InputMaybe<Scalars['String']>;
  fromAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_gt?: InputMaybe<Scalars['String']>;
  fromAccount_gte?: InputMaybe<Scalars['String']>;
  fromAccount_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_lt?: InputMaybe<Scalars['String']>;
  fromAccount_lte?: InputMaybe<Scalars['String']>;
  fromAccount_not?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_contains?: InputMaybe<Scalars['String']>;
  from_contains_nocase?: InputMaybe<Scalars['String']>;
  from_ends_with?: InputMaybe<Scalars['String']>;
  from_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_gt?: InputMaybe<Scalars['String']>;
  from_gte?: InputMaybe<Scalars['String']>;
  from_in?: InputMaybe<Array<Scalars['String']>>;
  from_lt?: InputMaybe<Scalars['String']>;
  from_lte?: InputMaybe<Scalars['String']>;
  from_not?: InputMaybe<Scalars['String']>;
  from_not_contains?: InputMaybe<Scalars['String']>;
  from_not_contains_nocase?: InputMaybe<Scalars['String']>;
  from_not_ends_with?: InputMaybe<Scalars['String']>;
  from_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_not_in?: InputMaybe<Array<Scalars['String']>>;
  from_not_starts_with?: InputMaybe<Scalars['String']>;
  from_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_starts_with?: InputMaybe<Scalars['String']>;
  from_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  or?: InputMaybe<Array<InputMaybe<Transfer_Filter>>>;
  storageID?: InputMaybe<Scalars['Int']>;
  storageID_gt?: InputMaybe<Scalars['Int']>;
  storageID_gte?: InputMaybe<Scalars['Int']>;
  storageID_in?: InputMaybe<Array<Scalars['Int']>>;
  storageID_lt?: InputMaybe<Scalars['Int']>;
  storageID_lte?: InputMaybe<Scalars['Int']>;
  storageID_not?: InputMaybe<Scalars['Int']>;
  storageID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to?: InputMaybe<Scalars['String']>;
  toAccount?: InputMaybe<Scalars['String']>;
  toAccount_?: InputMaybe<Account_Filter>;
  toAccount_contains?: InputMaybe<Scalars['String']>;
  toAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  toAccount_ends_with?: InputMaybe<Scalars['String']>;
  toAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_gt?: InputMaybe<Scalars['String']>;
  toAccount_gte?: InputMaybe<Scalars['String']>;
  toAccount_in?: InputMaybe<Array<Scalars['String']>>;
  toAccount_lt?: InputMaybe<Scalars['String']>;
  toAccount_lte?: InputMaybe<Scalars['String']>;
  toAccount_not?: InputMaybe<Scalars['String']>;
  toAccount_not_contains?: InputMaybe<Scalars['String']>;
  toAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  toAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  toAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  toAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  toAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_starts_with?: InputMaybe<Scalars['String']>;
  toAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  toTokenID?: InputMaybe<Scalars['Int']>;
  toTokenID_gt?: InputMaybe<Scalars['Int']>;
  toTokenID_gte?: InputMaybe<Scalars['Int']>;
  toTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  toTokenID_lt?: InputMaybe<Scalars['Int']>;
  toTokenID_lte?: InputMaybe<Scalars['Int']>;
  toTokenID_not?: InputMaybe<Scalars['Int']>;
  toTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to_contains?: InputMaybe<Scalars['String']>;
  to_contains_nocase?: InputMaybe<Scalars['String']>;
  to_ends_with?: InputMaybe<Scalars['String']>;
  to_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_gt?: InputMaybe<Scalars['String']>;
  to_gte?: InputMaybe<Scalars['String']>;
  to_in?: InputMaybe<Array<Scalars['String']>>;
  to_lt?: InputMaybe<Scalars['String']>;
  to_lte?: InputMaybe<Scalars['String']>;
  to_not?: InputMaybe<Scalars['String']>;
  to_not_contains?: InputMaybe<Scalars['String']>;
  to_not_contains_nocase?: InputMaybe<Scalars['String']>;
  to_not_ends_with?: InputMaybe<Scalars['String']>;
  to_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_not_in?: InputMaybe<Array<Scalars['String']>>;
  to_not_starts_with?: InputMaybe<Scalars['String']>;
  to_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_starts_with?: InputMaybe<Scalars['String']>;
  to_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum Transfer_OrderBy {
  AccountFromId = 'accountFromID',
  AccountToId = 'accountToID',
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  BlockAccountUpdateCount = 'block__accountUpdateCount',
  BlockAccountUpdateSize = 'block__accountUpdateSize',
  BlockAddCount = 'block__addCount',
  BlockAuxiliaryData = 'block__auxiliaryData',
  BlockBlockHash = 'block__blockHash',
  BlockBlockSize = 'block__blockSize',
  BlockBlockType = 'block__blockType',
  BlockBlockVersion = 'block__blockVersion',
  BlockData = 'block__data',
  BlockDepositCount = 'block__depositCount',
  BlockDepositSize = 'block__depositSize',
  BlockExchange = 'block__exchange',
  BlockGasLimit = 'block__gasLimit',
  BlockGasPrice = 'block__gasPrice',
  BlockHeight = 'block__height',
  BlockId = 'block__id',
  BlockInternalId = 'block__internalID',
  BlockNumConditionalTransactions = 'block__numConditionalTransactions',
  BlockOffchainData = 'block__offchainData',
  BlockOperatorAccountId = 'block__operatorAccountID',
  BlockOrderbookTradeCount = 'block__orderbookTradeCount',
  BlockProtocolFeeBips = 'block__protocolFeeBips',
  BlockRemoveCount = 'block__removeCount',
  BlockSignatureVerificationCount = 'block__signatureVerificationCount',
  BlockStoreBlockInfoOnchain = 'block__storeBlockInfoOnchain',
  BlockSwapCount = 'block__swapCount',
  BlockTimestamp = 'block__timestamp',
  BlockTransactionCount = 'block__transactionCount',
  BlockTransferCount = 'block__transferCount',
  BlockTxHash = 'block__txHash',
  BlockWithdrawSize = 'block__withdrawSize',
  BlockWithdrawalCount = 'block__withdrawalCount',
  Data = 'data',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  FeeTokenAddress = 'feeToken__address',
  FeeTokenDecimals = 'feeToken__decimals',
  FeeTokenId = 'feeToken__id',
  FeeTokenInternalId = 'feeToken__internalID',
  FeeTokenName = 'feeToken__name',
  FeeTokenSymbol = 'feeToken__symbol',
  FeeTokenTradedVolume = 'feeToken__tradedVolume',
  FeeTokenTradedVolumeOrderbook = 'feeToken__tradedVolumeOrderbook',
  FeeTokenTradedVolumeSwap = 'feeToken__tradedVolumeSwap',
  From = 'from',
  FromAccount = 'fromAccount',
  FromAccountAddress = 'fromAccount__address',
  FromAccountCreatedAt = 'fromAccount__createdAt',
  FromAccountId = 'fromAccount__id',
  FromAccountInternalId = 'fromAccount__internalID',
  FromAccountLastUpdatedAt = 'fromAccount__lastUpdatedAt',
  Id = 'id',
  InternalId = 'internalID',
  StorageId = 'storageID',
  To = 'to',
  ToAccount = 'toAccount',
  ToAccountAddress = 'toAccount__address',
  ToAccountCreatedAt = 'toAccount__createdAt',
  ToAccountId = 'toAccount__id',
  ToAccountInternalId = 'toAccount__internalID',
  ToAccountLastUpdatedAt = 'toAccount__lastUpdatedAt',
  ToTokenId = 'toTokenID',
  Token = 'token',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  TokenAddress = 'token__address',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenInternalId = 'token__internalID',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenTradedVolume = 'token__tradedVolume',
  TokenTradedVolumeOrderbook = 'token__tradedVolumeOrderbook',
  TokenTradedVolumeSwap = 'token__tradedVolumeSwap',
  Type = 'type',
  Typename = 'typename',
}

export type User = Account & {
  __typename?: 'User';
  address: Scalars['Bytes'];
  balances: Array<AccountTokenBalance>;
  /** L2 transaction internalID where the account was first created and linked to an address. Useful for sorting and filtering purposes */
  createdAt: Scalars['BigDecimal'];
  /** L2 transaction where the account was first created and linked to an address */
  createdAtTransaction: Transaction;
  /** Internal ID used in the L2 transactions */
  id: Scalars['ID'];
  /** Same as ID but expressed as a BigInt for sorting purposes */
  internalID: Scalars['BigInt'];
  /** L2 transaction internalID that last updated the account entity. Useful for sorting and filtering purposes */
  lastUpdatedAt: Scalars['BigDecimal'];
  /** L2 transaction that last updated the account entity */
  lastUpdatedAtTransaction: Transaction;
  /** String representing the public key for the User */
  publicKey?: Maybe<Scalars['String']>;
  /** L2 transactions that involved this account */
  transactions: Array<Transaction>;
};

export type UserBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type UserTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type User_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  address?: InputMaybe<Scalars['Bytes']>;
  address_contains?: InputMaybe<Scalars['Bytes']>;
  address_gt?: InputMaybe<Scalars['Bytes']>;
  address_gte?: InputMaybe<Scalars['Bytes']>;
  address_in?: InputMaybe<Array<Scalars['Bytes']>>;
  address_lt?: InputMaybe<Scalars['Bytes']>;
  address_lte?: InputMaybe<Scalars['Bytes']>;
  address_not?: InputMaybe<Scalars['Bytes']>;
  address_not_contains?: InputMaybe<Scalars['Bytes']>;
  address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<User_Filter>>>;
  balances_?: InputMaybe<AccountTokenBalance_Filter>;
  createdAt?: InputMaybe<Scalars['BigDecimal']>;
  createdAtTransaction?: InputMaybe<Scalars['String']>;
  createdAtTransaction_?: InputMaybe<Transaction_Filter>;
  createdAtTransaction_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_lt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_lte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  createdAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  lastUpdatedAt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAtTransaction?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_?: InputMaybe<Transaction_Filter>;
  lastUpdatedAtTransaction_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_lt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_lte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  lastUpdatedAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  or?: InputMaybe<Array<InputMaybe<User_Filter>>>;
  publicKey?: InputMaybe<Scalars['String']>;
  publicKey_contains?: InputMaybe<Scalars['String']>;
  publicKey_contains_nocase?: InputMaybe<Scalars['String']>;
  publicKey_ends_with?: InputMaybe<Scalars['String']>;
  publicKey_ends_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_gt?: InputMaybe<Scalars['String']>;
  publicKey_gte?: InputMaybe<Scalars['String']>;
  publicKey_in?: InputMaybe<Array<Scalars['String']>>;
  publicKey_lt?: InputMaybe<Scalars['String']>;
  publicKey_lte?: InputMaybe<Scalars['String']>;
  publicKey_not?: InputMaybe<Scalars['String']>;
  publicKey_not_contains?: InputMaybe<Scalars['String']>;
  publicKey_not_contains_nocase?: InputMaybe<Scalars['String']>;
  publicKey_not_ends_with?: InputMaybe<Scalars['String']>;
  publicKey_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_not_in?: InputMaybe<Array<Scalars['String']>>;
  publicKey_not_starts_with?: InputMaybe<Scalars['String']>;
  publicKey_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_starts_with?: InputMaybe<Scalars['String']>;
  publicKey_starts_with_nocase?: InputMaybe<Scalars['String']>;
  transactions_?: InputMaybe<Transaction_Filter>;
};

export enum User_OrderBy {
  Address = 'address',
  Balances = 'balances',
  CreatedAt = 'createdAt',
  CreatedAtTransaction = 'createdAtTransaction',
  CreatedAtTransactionData = 'createdAtTransaction__data',
  CreatedAtTransactionId = 'createdAtTransaction__id',
  CreatedAtTransactionInternalId = 'createdAtTransaction__internalID',
  CreatedAtTransactionTypename = 'createdAtTransaction__typename',
  Id = 'id',
  InternalId = 'internalID',
  LastUpdatedAt = 'lastUpdatedAt',
  LastUpdatedAtTransaction = 'lastUpdatedAtTransaction',
  LastUpdatedAtTransactionData = 'lastUpdatedAtTransaction__data',
  LastUpdatedAtTransactionId = 'lastUpdatedAtTransaction__id',
  LastUpdatedAtTransactionInternalId = 'lastUpdatedAtTransaction__internalID',
  LastUpdatedAtTransactionTypename = 'lastUpdatedAtTransaction__typename',
  PublicKey = 'publicKey',
  Transactions = 'transactions',
}

export type Withdrawal = Transaction & {
  __typename?: 'Withdrawal';
  accounts?: Maybe<Array<Account>>;
  /** [RAW L2 DATA] Amount withdrawn */
  amount: Scalars['BigInt'];
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Fee amount paid */
  fee: Scalars['BigInt'];
  /** Token entity with information about the token used to pay the operator fees */
  feeToken?: Maybe<Token>;
  /** [RAW L2 DATA] Token ID of token used to pay the operator fees */
  feeTokenID: Scalars['Int'];
  /** [RAW L2 DATA] Address string of the account that withdrew */
  from: Scalars['String'];
  /** Account entity that withdrew the tokens */
  fromAccount: Account;
  /** [RAW L2 DATA] Account ID for the account that withdrew */
  fromAccountID: Scalars['Int'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] On-chain data hash */
  onchainDataHash: Scalars['String'];
  /** [RAW L2 DATA] StorageID */
  storageID: Scalars['Int'];
  /** Token entity with information about the withdrawn token */
  token?: Maybe<Token>;
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of the withdrawn token */
  tokenID: Scalars['Int'];
  /** [RAW L2 DATA] Withdrawal type */
  type: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
  /** Whether the withdrawal transaction is valid. Only type 3 withdrawals are invalid. */
  valid: Scalars['Boolean'];
};

export type WithdrawalAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type WithdrawalTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type Withdrawal_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<Withdrawal_Filter>>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  from?: InputMaybe<Scalars['String']>;
  fromAccount?: InputMaybe<Scalars['String']>;
  fromAccountID?: InputMaybe<Scalars['Int']>;
  fromAccountID_gt?: InputMaybe<Scalars['Int']>;
  fromAccountID_gte?: InputMaybe<Scalars['Int']>;
  fromAccountID_in?: InputMaybe<Array<Scalars['Int']>>;
  fromAccountID_lt?: InputMaybe<Scalars['Int']>;
  fromAccountID_lte?: InputMaybe<Scalars['Int']>;
  fromAccountID_not?: InputMaybe<Scalars['Int']>;
  fromAccountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  fromAccount_?: InputMaybe<Account_Filter>;
  fromAccount_contains?: InputMaybe<Scalars['String']>;
  fromAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_gt?: InputMaybe<Scalars['String']>;
  fromAccount_gte?: InputMaybe<Scalars['String']>;
  fromAccount_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_lt?: InputMaybe<Scalars['String']>;
  fromAccount_lte?: InputMaybe<Scalars['String']>;
  fromAccount_not?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_contains?: InputMaybe<Scalars['String']>;
  from_contains_nocase?: InputMaybe<Scalars['String']>;
  from_ends_with?: InputMaybe<Scalars['String']>;
  from_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_gt?: InputMaybe<Scalars['String']>;
  from_gte?: InputMaybe<Scalars['String']>;
  from_in?: InputMaybe<Array<Scalars['String']>>;
  from_lt?: InputMaybe<Scalars['String']>;
  from_lte?: InputMaybe<Scalars['String']>;
  from_not?: InputMaybe<Scalars['String']>;
  from_not_contains?: InputMaybe<Scalars['String']>;
  from_not_contains_nocase?: InputMaybe<Scalars['String']>;
  from_not_ends_with?: InputMaybe<Scalars['String']>;
  from_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_not_in?: InputMaybe<Array<Scalars['String']>>;
  from_not_starts_with?: InputMaybe<Scalars['String']>;
  from_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_starts_with?: InputMaybe<Scalars['String']>;
  from_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  onchainDataHash?: InputMaybe<Scalars['String']>;
  onchainDataHash_contains?: InputMaybe<Scalars['String']>;
  onchainDataHash_contains_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_ends_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_ends_with_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_gt?: InputMaybe<Scalars['String']>;
  onchainDataHash_gte?: InputMaybe<Scalars['String']>;
  onchainDataHash_in?: InputMaybe<Array<Scalars['String']>>;
  onchainDataHash_lt?: InputMaybe<Scalars['String']>;
  onchainDataHash_lte?: InputMaybe<Scalars['String']>;
  onchainDataHash_not?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_contains?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_contains_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_ends_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_in?: InputMaybe<Array<Scalars['String']>>;
  onchainDataHash_not_starts_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_starts_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<Withdrawal_Filter>>>;
  storageID?: InputMaybe<Scalars['Int']>;
  storageID_gt?: InputMaybe<Scalars['Int']>;
  storageID_gte?: InputMaybe<Scalars['Int']>;
  storageID_in?: InputMaybe<Array<Scalars['Int']>>;
  storageID_lt?: InputMaybe<Scalars['Int']>;
  storageID_lte?: InputMaybe<Scalars['Int']>;
  storageID_not?: InputMaybe<Scalars['Int']>;
  storageID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
  valid?: InputMaybe<Scalars['Boolean']>;
  valid_in?: InputMaybe<Array<Scalars['Boolean']>>;
  valid_not?: InputMaybe<Scalars['Boolean']>;
  valid_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
};

export enum Withdrawal_OrderBy {
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  BlockAccountUpdateCount = 'block__accountUpdateCount',
  BlockAccountUpdateSize = 'block__accountUpdateSize',
  BlockAddCount = 'block__addCount',
  BlockAuxiliaryData = 'block__auxiliaryData',
  BlockBlockHash = 'block__blockHash',
  BlockBlockSize = 'block__blockSize',
  BlockBlockType = 'block__blockType',
  BlockBlockVersion = 'block__blockVersion',
  BlockData = 'block__data',
  BlockDepositCount = 'block__depositCount',
  BlockDepositSize = 'block__depositSize',
  BlockExchange = 'block__exchange',
  BlockGasLimit = 'block__gasLimit',
  BlockGasPrice = 'block__gasPrice',
  BlockHeight = 'block__height',
  BlockId = 'block__id',
  BlockInternalId = 'block__internalID',
  BlockNumConditionalTransactions = 'block__numConditionalTransactions',
  BlockOffchainData = 'block__offchainData',
  BlockOperatorAccountId = 'block__operatorAccountID',
  BlockOrderbookTradeCount = 'block__orderbookTradeCount',
  BlockProtocolFeeBips = 'block__protocolFeeBips',
  BlockRemoveCount = 'block__removeCount',
  BlockSignatureVerificationCount = 'block__signatureVerificationCount',
  BlockStoreBlockInfoOnchain = 'block__storeBlockInfoOnchain',
  BlockSwapCount = 'block__swapCount',
  BlockTimestamp = 'block__timestamp',
  BlockTransactionCount = 'block__transactionCount',
  BlockTransferCount = 'block__transferCount',
  BlockTxHash = 'block__txHash',
  BlockWithdrawSize = 'block__withdrawSize',
  BlockWithdrawalCount = 'block__withdrawalCount',
  Data = 'data',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  FeeTokenAddress = 'feeToken__address',
  FeeTokenDecimals = 'feeToken__decimals',
  FeeTokenId = 'feeToken__id',
  FeeTokenInternalId = 'feeToken__internalID',
  FeeTokenName = 'feeToken__name',
  FeeTokenSymbol = 'feeToken__symbol',
  FeeTokenTradedVolume = 'feeToken__tradedVolume',
  FeeTokenTradedVolumeOrderbook = 'feeToken__tradedVolumeOrderbook',
  FeeTokenTradedVolumeSwap = 'feeToken__tradedVolumeSwap',
  From = 'from',
  FromAccount = 'fromAccount',
  FromAccountId = 'fromAccountID',
  FromAccountAddress = 'fromAccount__address',
  FromAccountCreatedAt = 'fromAccount__createdAt',
  FromAccountId = 'fromAccount__id',
  FromAccountInternalId = 'fromAccount__internalID',
  FromAccountLastUpdatedAt = 'fromAccount__lastUpdatedAt',
  Id = 'id',
  InternalId = 'internalID',
  OnchainDataHash = 'onchainDataHash',
  StorageId = 'storageID',
  Token = 'token',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  TokenAddress = 'token__address',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenInternalId = 'token__internalID',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenTradedVolume = 'token__tradedVolume',
  TokenTradedVolumeOrderbook = 'token__tradedVolumeOrderbook',
  TokenTradedVolumeSwap = 'token__tradedVolumeSwap',
  Type = 'type',
  Typename = 'typename',
  Valid = 'valid',
}

export type _Block_ = {
  __typename?: '_Block_';
  /** The hash of the block */
  hash?: Maybe<Scalars['Bytes']>;
  /** The block number */
  number: Scalars['Int'];
  /** The hash of the parent block */
  parentHash?: Maybe<Scalars['Bytes']>;
  /** Integer representation of the timestamp stored in blocks for the chain */
  timestamp?: Maybe<Scalars['Int']>;
};

/** The type for the top-level _meta field */
export type _Meta_ = {
  __typename?: '_Meta_';
  /**
   * Information about a specific subgraph block. The hash of the block
   * will be null if the _meta field has a block constraint that asks for
   * a block number. It will be filled if the _meta field has no block constraint
   * and therefore asks for the latest  block
   *
   */
  block: _Block_;
  /** The deployment ID */
  deployment: Scalars['String'];
  /** If `true`, the subgraph encountered indexing errors at some past block */
  hasIndexingErrors: Scalars['Boolean'];
};

export enum _SubgraphErrorPolicy_ {
  /** Data will be returned even if the subgraph has indexing errors */
  Allow = 'allow',
  /** If the subgraph has indexing errors, data will be omitted. The default. */
  Deny = 'deny',
}

type AccountFragment_ProtocolAccount_Fragment = { __typename?: 'ProtocolAccount'; id: string; address: any };

type AccountFragment_User_Fragment = { __typename?: 'User'; id: string; address: any };

export type AccountFragmentFragment = AccountFragment_ProtocolAccount_Fragment | AccountFragment_User_Fragment;

export type TokenFragmentFragment = {
  __typename?: 'Token';
  id: string;
  name: string;
  symbol: string;
  decimals: number;
  address: any;
};

export type BlockFragmentFragment = {
  __typename?: 'Block';
  id: string;
  timestamp: any;
  txHash: string;
  gasLimit: any;
  gasPrice: any;
  height: any;
  blockHash: string;
  blockSize: number;
  operatorAccount:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
};

export type OrderbookTradeFragmentFragment = {
  __typename: 'OrderbookTrade';
  id: string;
  tokenAPrice: any;
  tokenBPrice: any;
  fillSA: any;
  fillSB: any;
  fillBA: any;
  fillBB: any;
  fillAmountBorSA: boolean;
  fillAmountBorSB: boolean;
  feeA: any;
  feeB: any;
  accountA:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  accountB:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  pair: {
    __typename?: 'Pair';
    id: string;
    token0: { __typename?: 'Token'; symbol: string };
    token1: { __typename?: 'Token'; symbol: string };
  };
};

export type BatchSpotTradeFragmentFragment = {
  __typename: 'BatchSpotTrade';
  accountBFirstTokenID?: number | null;
  accountBSecondTokenID?: number | null;
  accountCFirstTokenID?: number | null;
  accountCSecondTokenID?: number | null;
  accountDFirstTokenID?: number | null;
  accountDSecondTokenID?: number | null;
  accountEFirstTokenID?: number | null;
  accountESecondTokenID?: number | null;
  accountFFirstTokenID?: number | null;
  accountFSecondTokenID?: number | null;
  accountAFirstTokenAmountExchange: any;
  accountASecondTokenAmountExchange: any;
  accountAThirdTokenAmountExchange: any;
  accountBFirstTokenAmountExchange: any;
  accountBSecondTokenAmountExchange: any;
  accountCFirstTokenAmountExchange: any;
  accountCSecondTokenAmountExchange: any;
  accountDFirstTokenAmountExchange: any;
  accountDSecondTokenAmountExchange: any;
  accountEFirstTokenAmountExchange: any;
  accountESecondTokenAmountExchange: any;
  accountFFirstTokenAmountExchange: any;
  accountFSecondTokenAmountExchange: any;
  bindToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  accountA:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  accountB:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  accountC?:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any }
    | null;
  accountD?:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any }
    | null;
  accountE?:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any }
    | null;
  accountF?:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any }
    | null;
};

export type DepositFragmentFragment = {
  __typename: 'Deposit';
  id: string;
  amount: any;
  toAccount:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
};

export type WithdrawalFragmentFragment = {
  __typename: 'Withdrawal';
  amount: any;
  fee: any;
  fromAccount:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  withdrawalToken?: {
    __typename?: 'Token';
    id: string;
    name: string;
    symbol: string;
    decimals: number;
    address: any;
  } | null;
  withdrawalFeeToken?: {
    __typename?: 'Token';
    id: string;
    name: string;
    symbol: string;
    decimals: number;
    address: any;
  } | null;
};

export type TransferFragmentFragment = {
  __typename: 'Transfer';
  amount: any;
  fee: any;
  fromAccount:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  toAccount:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
};

export type AccountUpdateFragmentFragment = {
  __typename: 'AccountUpdate';
  fee: any;
  nonce: number;
  user: { __typename?: 'User'; id: string; address: any; publicKey?: string | null };
  feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
};

export type SignatureVerificationFragmentFragment = {
  __typename: 'SignatureVerification';
  verificationData: string;
  account:
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
};

export type AccountsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
}>;

export type AccountsQuery = {
  __typename?: 'Query';
  accounts: Array<
    | {
        __typename: 'ProtocolAccount';
        id: string;
        address: any;
        createdAtTransaction:
          | { __typename?: 'AccountUpdate'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'BatchSpotTrade'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Deposit'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'OrderbookTrade'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'SignatureVerification'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Transfer'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Withdrawal'; id: string; block: { __typename?: 'Block'; timestamp: any } };
      }
    | {
        __typename: 'User';
        id: string;
        address: any;
        createdAtTransaction:
          | { __typename?: 'AccountUpdate'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'BatchSpotTrade'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Deposit'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'OrderbookTrade'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'SignatureVerification'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Transfer'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Withdrawal'; id: string; block: { __typename?: 'Block'; timestamp: any } };
      }
  >;
};

export type AccountTokenBalancesQueryVariables = Exact<{
  where?: InputMaybe<AccountTokenBalance_Filter>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type AccountTokenBalancesQuery = {
  __typename?: 'Query';
  accountTokenBalances: Array<{
    __typename: 'AccountTokenBalance';
    id: string;
    balance: any;
    token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  }>;
};

export type BlocksQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Block_Filter>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type BlocksQuery = {
  __typename?: 'Query';
  blocks: Array<{
    __typename?: 'Block';
    transactionCount: any;
    id: string;
    timestamp: any;
    txHash: string;
    gasLimit: any;
    gasPrice: any;
    height: any;
    blockHash: string;
    blockSize: number;
    operatorAccount:
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
  }>;
};

export type BlockQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type BlockQuery = {
  __typename?: 'Query';
  proxy?: { __typename?: 'Proxy'; blockCount: any } | null;
  block?: {
    __typename?: 'Block';
    data: string;
    id: string;
    timestamp: any;
    txHash: string;
    gasLimit: any;
    gasPrice: any;
    height: any;
    blockHash: string;
    blockSize: number;
    operatorAccount:
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
  } | null;
};

export type NetworkStatsQueryVariables = Exact<{ [key: string]: never }>;

export type NetworkStatsQuery = {
  __typename?: 'Query';
  proxy?: { __typename?: 'Proxy'; blockCount: any; userCount: any; transactionCount: any } | null;
  blocks: Array<{ __typename?: 'Block'; id: string; transactionCount: any; timestamp: any }>;
};

export type PairsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Pair_Filter>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type PairsQuery = {
  __typename?: 'Query';
  pairs: Array<{
    __typename?: 'Pair';
    id: string;
    internalID: any;
    tradedVolumeToken0Swap: any;
    token0: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    token1: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    dailyEntities: Array<{
      __typename?: 'PairDailyData';
      tradedVolumeToken1Swap: any;
      tradedVolumeToken0Swap: any;
      id: string;
    }>;
    weeklyEntities: Array<{
      __typename?: 'PairWeeklyData';
      tradedVolumeToken1Swap: any;
      tradedVolumeToken0Swap: any;
      id: string;
    }>;
  }>;
};

export type PairQueryVariables = Exact<{
  id: Scalars['ID'];
  swapSkip?: InputMaybe<Scalars['Int']>;
  swapFirst?: InputMaybe<Scalars['Int']>;
  orderbookSkip?: InputMaybe<Scalars['Int']>;
  orderbookFirst?: InputMaybe<Scalars['Int']>;
}>;

export type PairQuery = {
  __typename?: 'Query';
  pair?: {
    __typename: 'Pair';
    id: string;
    internalID: any;
    token0Price: any;
    token1Price: any;
    tradedVolumeToken0Swap: any;
    tradedVolumeToken1Swap: any;
    tradedVolumeToken0Orderbook: any;
    tradedVolumeToken1Orderbook: any;
    token0: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    token1: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    trades: Array<{
      __typename: 'OrderbookTrade';
      id: string;
      tokenAPrice: any;
      tokenBPrice: any;
      fillSA: any;
      fillSB: any;
      fillBA: any;
      fillBB: any;
      fillAmountBorSA: boolean;
      fillAmountBorSB: boolean;
      feeA: any;
      feeB: any;
      block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
      accountA:
        | { __typename?: 'ProtocolAccount'; id: string; address: any }
        | { __typename?: 'User'; id: string; address: any };
      accountB:
        | { __typename?: 'ProtocolAccount'; id: string; address: any }
        | { __typename?: 'User'; id: string; address: any };
      tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      pair: {
        __typename?: 'Pair';
        id: string;
        token0: { __typename?: 'Token'; symbol: string };
        token1: { __typename?: 'Token'; symbol: string };
      };
    }>;
    dailyEntities: Array<{
      __typename?: 'PairDailyData';
      dayEnd: any;
      tradedVolumeToken0: any;
      tradedVolumeToken1: any;
      tradedVolumeToken0Swap: any;
      tradedVolumeToken1Swap: any;
      tradedVolumeToken0Orderbook: any;
      tradedVolumeToken1Orderbook: any;
    }>;
    weeklyEntities: Array<{
      __typename?: 'PairWeeklyData';
      weekEnd: any;
      tradedVolumeToken0: any;
      tradedVolumeToken1: any;
      tradedVolumeToken0Swap: any;
      tradedVolumeToken1Swap: any;
      tradedVolumeToken0Orderbook: any;
      tradedVolumeToken1Orderbook: any;
    }>;
  } | null;
};

export type PairTradesQueryVariables = Exact<{
  where?: InputMaybe<OrderbookTrade_Filter>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type PairTradesQuery = {
  __typename?: 'Query';
  orderbookTrades: Array<{
    __typename: 'OrderbookTrade';
    internalID: any;
    id: string;
    tokenAPrice: any;
    tokenBPrice: any;
    fillSA: any;
    fillSB: any;
    fillBA: any;
    fillBB: any;
    fillAmountBorSA: boolean;
    fillAmountBorSB: boolean;
    feeA: any;
    feeB: any;
    block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
    accountA:
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
    accountB:
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
    tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    pair: {
      __typename?: 'Pair';
      id: string;
      token0: { __typename?: 'Token'; symbol: string };
      token1: { __typename?: 'Token'; symbol: string };
    };
  }>;
};

export type TransactionsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Transaction_Filter>;
}>;

export type TransactionsQuery = {
  __typename?: 'Query';
  transactions: Array<
    | {
        __typename: 'AccountUpdate';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        nonce: number;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        user: { __typename?: 'User'; id: string; address: any; publicKey?: string | null };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'BatchSpotTrade';
        id: string;
        internalID: any;
        data: string;
        accountBFirstTokenID?: number | null;
        accountBSecondTokenID?: number | null;
        accountCFirstTokenID?: number | null;
        accountCSecondTokenID?: number | null;
        accountDFirstTokenID?: number | null;
        accountDSecondTokenID?: number | null;
        accountEFirstTokenID?: number | null;
        accountESecondTokenID?: number | null;
        accountFFirstTokenID?: number | null;
        accountFSecondTokenID?: number | null;
        accountAFirstTokenAmountExchange: any;
        accountASecondTokenAmountExchange: any;
        accountAThirdTokenAmountExchange: any;
        accountBFirstTokenAmountExchange: any;
        accountBSecondTokenAmountExchange: any;
        accountCFirstTokenAmountExchange: any;
        accountCSecondTokenAmountExchange: any;
        accountDFirstTokenAmountExchange: any;
        accountDSecondTokenAmountExchange: any;
        accountEFirstTokenAmountExchange: any;
        accountESecondTokenAmountExchange: any;
        accountFFirstTokenAmountExchange: any;
        accountFSecondTokenAmountExchange: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        bindToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        accountA:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountB:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountC?:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any }
          | null;
        accountD?:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any }
          | null;
        accountE?:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any }
          | null;
        accountF?:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any }
          | null;
      }
    | {
        __typename: 'Deposit';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        toAccount:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'OrderbookTrade';
        id: string;
        internalID: any;
        data: string;
        tokenAPrice: any;
        tokenBPrice: any;
        fillSA: any;
        fillSB: any;
        fillBA: any;
        fillBB: any;
        fillAmountBorSA: boolean;
        fillAmountBorSB: boolean;
        feeA: any;
        feeB: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        accountA:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountB:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        pair: {
          __typename?: 'Pair';
          id: string;
          token0: { __typename?: 'Token'; symbol: string };
          token1: { __typename?: 'Token'; symbol: string };
        };
      }
    | {
        __typename: 'SignatureVerification';
        id: string;
        internalID: any;
        data: string;
        verificationData: string;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        account:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
      }
    | {
        __typename: 'Transfer';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        fromAccount:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        toAccount:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'Withdrawal';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        fromAccount:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        withdrawalToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
        withdrawalFeeToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
      }
  >;
};

export type TransactionQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type TransactionQuery = {
  __typename?: 'Query';
  transaction?:
    | {
        __typename: 'AccountUpdate';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        nonce: number;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        user: { __typename?: 'User'; id: string; address: any; publicKey?: string | null };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'BatchSpotTrade';
        id: string;
        internalID: any;
        data: string;
        accountBFirstTokenID?: number | null;
        accountBSecondTokenID?: number | null;
        accountCFirstTokenID?: number | null;
        accountCSecondTokenID?: number | null;
        accountDFirstTokenID?: number | null;
        accountDSecondTokenID?: number | null;
        accountEFirstTokenID?: number | null;
        accountESecondTokenID?: number | null;
        accountFFirstTokenID?: number | null;
        accountFSecondTokenID?: number | null;
        accountAFirstTokenAmountExchange: any;
        accountASecondTokenAmountExchange: any;
        accountAThirdTokenAmountExchange: any;
        accountBFirstTokenAmountExchange: any;
        accountBSecondTokenAmountExchange: any;
        accountCFirstTokenAmountExchange: any;
        accountCSecondTokenAmountExchange: any;
        accountDFirstTokenAmountExchange: any;
        accountDSecondTokenAmountExchange: any;
        accountEFirstTokenAmountExchange: any;
        accountESecondTokenAmountExchange: any;
        accountFFirstTokenAmountExchange: any;
        accountFSecondTokenAmountExchange: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        bindToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        accountA:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountB:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountC?:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any }
          | null;
        accountD?:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any }
          | null;
        accountE?:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any }
          | null;
        accountF?:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any }
          | null;
      }
    | {
        __typename: 'Deposit';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        toAccount:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'OrderbookTrade';
        id: string;
        internalID: any;
        data: string;
        tokenAPrice: any;
        tokenBPrice: any;
        fillSA: any;
        fillSB: any;
        fillBA: any;
        fillBB: any;
        fillAmountBorSA: boolean;
        fillAmountBorSB: boolean;
        feeA: any;
        feeB: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        accountA:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountB:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        pair: {
          __typename?: 'Pair';
          id: string;
          token0: { __typename?: 'Token'; symbol: string };
          token1: { __typename?: 'Token'; symbol: string };
        };
      }
    | {
        __typename: 'SignatureVerification';
        id: string;
        internalID: any;
        data: string;
        verificationData: string;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        account:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
      }
    | {
        __typename: 'Transfer';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        fromAccount:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        toAccount:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'Withdrawal';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        fromAccount:
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        withdrawalToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
        withdrawalFeeToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
      }
    | null;
};

export type PendingTransactionsQueryVariables = Exact<{
  transferWhere?: InputMaybe<Transfer_Filter>;
  withdrawalWhere?: InputMaybe<Withdrawal_Filter>;
  orderBookTradeWhere?: InputMaybe<OrderbookTrade_Filter>;
  accountUpdateWhere?: InputMaybe<AccountUpdate_Filter>;
}>;

export type PendingTransactionsQuery = {
  __typename?: 'Query';
  transfers: Array<{ __typename?: 'Transfer'; id: string }>;
  withdrawals: Array<{ __typename?: 'Withdrawal'; id: string }>;
  orderbookTrades: Array<{ __typename?: 'OrderbookTrade'; id: string }>;
  accountUpdates: Array<{ __typename?: 'AccountUpdate'; id: string }>;
};

export const AccountFragmentFragmentDoc = gql`
  fragment AccountFragment on Account {
    id
    address
  }
`;
export const BlockFragmentFragmentDoc = gql`
  fragment BlockFragment on Block {
    id
    timestamp
    txHash
    gasLimit
    gasPrice
    height
    blockHash
    blockSize
    gasPrice
    operatorAccount {
      ...AccountFragment
    }
  }
  ${AccountFragmentFragmentDoc}
`;
export const TokenFragmentFragmentDoc = gql`
  fragment TokenFragment on Token {
    id
    name
    symbol
    decimals
    address
  }
`;
export const OrderbookTradeFragmentFragmentDoc = gql`
  fragment OrderbookTradeFragment on OrderbookTrade {
    id
    accountA {
      ...AccountFragment
    }
    accountB {
      ...AccountFragment
    }
    tokenA {
      ...TokenFragment
    }
    tokenB {
      ...TokenFragment
    }
    pair {
      id
      token0 {
        symbol
      }
      token1 {
        symbol
      }
    }
    tokenAPrice
    tokenBPrice
    fillSA
    fillSB
    fillBA
    fillBB
    fillAmountBorSA
    fillAmountBorSB
    feeA
    feeB
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const BatchSpotTradeFragmentFragmentDoc = gql`
  fragment BatchSpotTradeFragment on BatchSpotTrade {
    bindToken {
      ...TokenFragment
    }
    tokenA {
      ...TokenFragment
    }
    tokenB {
      ...TokenFragment
    }
    accountA {
      ...AccountFragment
    }
    accountB {
      ...AccountFragment
    }
    accountC {
      ...AccountFragment
    }
    accountD {
      ...AccountFragment
    }
    accountE {
      ...AccountFragment
    }
    accountF {
      ...AccountFragment
    }
    accountBFirstTokenID
    accountBSecondTokenID
    accountCFirstTokenID
    accountCSecondTokenID
    accountDFirstTokenID
    accountDSecondTokenID
    accountEFirstTokenID
    accountESecondTokenID
    accountFFirstTokenID
    accountFSecondTokenID
    accountAFirstTokenAmountExchange
    accountASecondTokenAmountExchange
    accountAThirdTokenAmountExchange
    accountBFirstTokenAmountExchange
    accountBSecondTokenAmountExchange
    accountCFirstTokenAmountExchange
    accountCSecondTokenAmountExchange
    accountDFirstTokenAmountExchange
    accountDSecondTokenAmountExchange
    accountEFirstTokenAmountExchange
    accountESecondTokenAmountExchange
    accountFFirstTokenAmountExchange
    accountFSecondTokenAmountExchange
    __typename
  }
  ${TokenFragmentFragmentDoc}
  ${AccountFragmentFragmentDoc}
`;
export const DepositFragmentFragmentDoc = gql`
  fragment DepositFragment on Deposit {
    id
    toAccount {
      ...AccountFragment
    }
    token {
      ...TokenFragment
    }
    amount
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const WithdrawalFragmentFragmentDoc = gql`
  fragment WithdrawalFragment on Withdrawal {
    fromAccount {
      ...AccountFragment
    }
    withdrawalToken: token {
      ...TokenFragment
    }
    withdrawalFeeToken: feeToken {
      ...TokenFragment
    }
    amount
    fee
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const TransferFragmentFragmentDoc = gql`
  fragment TransferFragment on Transfer {
    fromAccount {
      ...AccountFragment
    }
    toAccount {
      ...AccountFragment
    }
    token {
      ...TokenFragment
    }
    feeToken {
      ...TokenFragment
    }
    amount
    fee
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const AccountUpdateFragmentFragmentDoc = gql`
  fragment AccountUpdateFragment on AccountUpdate {
    user {
      id
      address
      publicKey
    }
    feeToken {
      ...TokenFragment
    }
    fee
    nonce
    __typename
  }
  ${TokenFragmentFragmentDoc}
`;
export const SignatureVerificationFragmentFragmentDoc = gql`
  fragment SignatureVerificationFragment on SignatureVerification {
    account {
      ...AccountFragment
    }
    verificationData
    __typename
  }
  ${AccountFragmentFragmentDoc}
`;
export const AccountsDocument = gql`
  query accounts($first: Int, $where: Account_filter) {
    accounts(first: $first, where: $where) {
      id
      address
      createdAtTransaction {
        id
        block {
          timestamp
        }
      }
      __typename
    }
  }
`;

/**
 * __useAccountsQuery__
 *
 * To run a query within a React component, call `useAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useAccountsQuery(baseOptions?: Apollo.QueryHookOptions<AccountsQuery, AccountsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<AccountsQuery, AccountsQueryVariables>(AccountsDocument, options);
}
export function useAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountsQuery, AccountsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<AccountsQuery, AccountsQueryVariables>(AccountsDocument, options);
}
export type AccountsQueryHookResult = ReturnType<typeof useAccountsQuery>;
export type AccountsLazyQueryHookResult = ReturnType<typeof useAccountsLazyQuery>;
export type AccountsQueryResult = Apollo.QueryResult<AccountsQuery, AccountsQueryVariables>;
export function refetchAccountsQuery(variables?: AccountsQueryVariables) {
  return { query: AccountsDocument, variables: variables };
}
export const AccountTokenBalancesDocument = gql`
  query accountTokenBalances($where: AccountTokenBalance_filter, $orderDirection: OrderDirection) {
    accountTokenBalances(orderDirection: $orderDirection, orderBy: id, first: 10, where: $where) {
      id
      balance
      token {
        ...TokenFragment
      }
      __typename
    }
  }
  ${TokenFragmentFragmentDoc}
`;

/**
 * __useAccountTokenBalancesQuery__
 *
 * To run a query within a React component, call `useAccountTokenBalancesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountTokenBalancesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountTokenBalancesQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function useAccountTokenBalancesQuery(
  baseOptions?: Apollo.QueryHookOptions<AccountTokenBalancesQuery, AccountTokenBalancesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<AccountTokenBalancesQuery, AccountTokenBalancesQueryVariables>(
    AccountTokenBalancesDocument,
    options
  );
}
export function useAccountTokenBalancesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<AccountTokenBalancesQuery, AccountTokenBalancesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<AccountTokenBalancesQuery, AccountTokenBalancesQueryVariables>(
    AccountTokenBalancesDocument,
    options
  );
}
export type AccountTokenBalancesQueryHookResult = ReturnType<typeof useAccountTokenBalancesQuery>;
export type AccountTokenBalancesLazyQueryHookResult = ReturnType<typeof useAccountTokenBalancesLazyQuery>;
export type AccountTokenBalancesQueryResult = Apollo.QueryResult<
  AccountTokenBalancesQuery,
  AccountTokenBalancesQueryVariables
>;
export function refetchAccountTokenBalancesQuery(variables?: AccountTokenBalancesQueryVariables) {
  return { query: AccountTokenBalancesDocument, variables: variables };
}
export const BlocksDocument = gql`
  query blocks($first: Int, $where: Block_filter, $orderDirection: OrderDirection) {
    blocks(first: $first, where: $where, orderBy: internalID, orderDirection: $orderDirection) {
      ...BlockFragment
      transactionCount
    }
  }
  ${BlockFragmentFragmentDoc}
`;

/**
 * __useBlocksQuery__
 *
 * To run a query within a React component, call `useBlocksQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlocksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlocksQuery({
 *   variables: {
 *      first: // value for 'first'
 *      where: // value for 'where'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function useBlocksQuery(baseOptions?: Apollo.QueryHookOptions<BlocksQuery, BlocksQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<BlocksQuery, BlocksQueryVariables>(BlocksDocument, options);
}
export function useBlocksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BlocksQuery, BlocksQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<BlocksQuery, BlocksQueryVariables>(BlocksDocument, options);
}
export type BlocksQueryHookResult = ReturnType<typeof useBlocksQuery>;
export type BlocksLazyQueryHookResult = ReturnType<typeof useBlocksLazyQuery>;
export type BlocksQueryResult = Apollo.QueryResult<BlocksQuery, BlocksQueryVariables>;
export function refetchBlocksQuery(variables?: BlocksQueryVariables) {
  return { query: BlocksDocument, variables: variables };
}
export const BlockDocument = gql`
  query block($id: ID!) {
    proxy(id: 0) {
      blockCount
    }
    block(id: $id) {
      ...BlockFragment
      data
    }
  }
  ${BlockFragmentFragmentDoc}
`;

/**
 * __useBlockQuery__
 *
 * To run a query within a React component, call `useBlockQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlockQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlockQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBlockQuery(baseOptions: Apollo.QueryHookOptions<BlockQuery, BlockQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<BlockQuery, BlockQueryVariables>(BlockDocument, options);
}
export function useBlockLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BlockQuery, BlockQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<BlockQuery, BlockQueryVariables>(BlockDocument, options);
}
export type BlockQueryHookResult = ReturnType<typeof useBlockQuery>;
export type BlockLazyQueryHookResult = ReturnType<typeof useBlockLazyQuery>;
export type BlockQueryResult = Apollo.QueryResult<BlockQuery, BlockQueryVariables>;
export function refetchBlockQuery(variables: BlockQueryVariables) {
  return { query: BlockDocument, variables: variables };
}
export const NetworkStatsDocument = gql`
  query networkStats {
    proxy(id: 0) {
      blockCount
      userCount
      transactionCount
    }
    blocks(first: 10, orderBy: internalID, orderDirection: desc) {
      id
      transactionCount
      timestamp
    }
  }
`;

/**
 * __useNetworkStatsQuery__
 *
 * To run a query within a React component, call `useNetworkStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNetworkStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNetworkStatsQuery({
 *   variables: {
 *   },
 * });
 */
export function useNetworkStatsQuery(
  baseOptions?: Apollo.QueryHookOptions<NetworkStatsQuery, NetworkStatsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<NetworkStatsQuery, NetworkStatsQueryVariables>(NetworkStatsDocument, options);
}
export function useNetworkStatsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<NetworkStatsQuery, NetworkStatsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<NetworkStatsQuery, NetworkStatsQueryVariables>(NetworkStatsDocument, options);
}
export type NetworkStatsQueryHookResult = ReturnType<typeof useNetworkStatsQuery>;
export type NetworkStatsLazyQueryHookResult = ReturnType<typeof useNetworkStatsLazyQuery>;
export type NetworkStatsQueryResult = Apollo.QueryResult<NetworkStatsQuery, NetworkStatsQueryVariables>;
export function refetchNetworkStatsQuery(variables?: NetworkStatsQueryVariables) {
  return { query: NetworkStatsDocument, variables: variables };
}
export const PairsDocument = gql`
  query pairs($first: Int, $where: Pair_filter, $orderDirection: OrderDirection) {
    pairs(first: $first, where: $where, orderBy: tradedVolumeToken0Swap, orderDirection: $orderDirection) {
      id
      internalID
      token0 {
        ...TokenFragment
      }
      token1 {
        ...TokenFragment
      }
      tradedVolumeToken0Swap
      dailyEntities(skip: 1, first: 1, orderBy: dayEnd, orderDirection: desc) {
        tradedVolumeToken1Swap
        tradedVolumeToken0Swap
        id
      }
      weeklyEntities(skip: 0, first: 1, orderBy: weekEnd, orderDirection: desc) {
        tradedVolumeToken1Swap
        tradedVolumeToken0Swap
        id
      }
    }
  }
  ${TokenFragmentFragmentDoc}
`;

/**
 * __usePairsQuery__
 *
 * To run a query within a React component, call `usePairsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePairsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePairsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      where: // value for 'where'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function usePairsQuery(baseOptions?: Apollo.QueryHookOptions<PairsQuery, PairsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<PairsQuery, PairsQueryVariables>(PairsDocument, options);
}
export function usePairsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PairsQuery, PairsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<PairsQuery, PairsQueryVariables>(PairsDocument, options);
}
export type PairsQueryHookResult = ReturnType<typeof usePairsQuery>;
export type PairsLazyQueryHookResult = ReturnType<typeof usePairsLazyQuery>;
export type PairsQueryResult = Apollo.QueryResult<PairsQuery, PairsQueryVariables>;
export function refetchPairsQuery(variables?: PairsQueryVariables) {
  return { query: PairsDocument, variables: variables };
}
export const PairDocument = gql`
  query pair($id: ID!, $swapSkip: Int, $swapFirst: Int, $orderbookSkip: Int, $orderbookFirst: Int) {
    pair(id: $id) {
      id
      internalID
      token0 {
        ...TokenFragment
      }
      token1 {
        ...TokenFragment
      }
      token0Price
      token1Price
      tradedVolumeToken0Swap
      tradedVolumeToken1Swap
      tradedVolumeToken0Orderbook
      tradedVolumeToken1Orderbook
      trades(skip: $orderbookSkip, first: $orderbookFirst, orderDirection: desc, orderBy: internalID) {
        block {
          id
          blockHash
          timestamp
        }
        ...OrderbookTradeFragment
      }
      dailyEntities(skip: 1, first: 90, orderDirection: desc, orderBy: dayEnd) {
        dayEnd
        tradedVolumeToken0
        tradedVolumeToken1
        tradedVolumeToken0Swap
        tradedVolumeToken1Swap
        tradedVolumeToken0Orderbook
        tradedVolumeToken1Orderbook
      }
      weeklyEntities(skip: 1, first: 90, orderDirection: desc, orderBy: weekEnd) {
        weekEnd
        tradedVolumeToken0
        tradedVolumeToken1
        tradedVolumeToken0Swap
        tradedVolumeToken1Swap
        tradedVolumeToken0Orderbook
        tradedVolumeToken1Orderbook
      }
      __typename
    }
  }
  ${TokenFragmentFragmentDoc}
  ${OrderbookTradeFragmentFragmentDoc}
`;

/**
 * __usePairQuery__
 *
 * To run a query within a React component, call `usePairQuery` and pass it any options that fit your needs.
 * When your component renders, `usePairQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePairQuery({
 *   variables: {
 *      id: // value for 'id'
 *      swapSkip: // value for 'swapSkip'
 *      swapFirst: // value for 'swapFirst'
 *      orderbookSkip: // value for 'orderbookSkip'
 *      orderbookFirst: // value for 'orderbookFirst'
 *   },
 * });
 */
export function usePairQuery(baseOptions: Apollo.QueryHookOptions<PairQuery, PairQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<PairQuery, PairQueryVariables>(PairDocument, options);
}
export function usePairLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PairQuery, PairQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<PairQuery, PairQueryVariables>(PairDocument, options);
}
export type PairQueryHookResult = ReturnType<typeof usePairQuery>;
export type PairLazyQueryHookResult = ReturnType<typeof usePairLazyQuery>;
export type PairQueryResult = Apollo.QueryResult<PairQuery, PairQueryVariables>;
export function refetchPairQuery(variables: PairQueryVariables) {
  return { query: PairDocument, variables: variables };
}
export const PairTradesDocument = gql`
  query pairTrades($where: OrderbookTrade_filter, $orderDirection: OrderDirection) {
    orderbookTrades(first: 10, orderDirection: $orderDirection, orderBy: internalID, where: $where) {
      block {
        id
        blockHash
        timestamp
      }
      internalID
      ...OrderbookTradeFragment
    }
  }
  ${OrderbookTradeFragmentFragmentDoc}
`;

/**
 * __usePairTradesQuery__
 *
 * To run a query within a React component, call `usePairTradesQuery` and pass it any options that fit your needs.
 * When your component renders, `usePairTradesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePairTradesQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function usePairTradesQuery(baseOptions?: Apollo.QueryHookOptions<PairTradesQuery, PairTradesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<PairTradesQuery, PairTradesQueryVariables>(PairTradesDocument, options);
}
export function usePairTradesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<PairTradesQuery, PairTradesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<PairTradesQuery, PairTradesQueryVariables>(PairTradesDocument, options);
}
export type PairTradesQueryHookResult = ReturnType<typeof usePairTradesQuery>;
export type PairTradesLazyQueryHookResult = ReturnType<typeof usePairTradesLazyQuery>;
export type PairTradesQueryResult = Apollo.QueryResult<PairTradesQuery, PairTradesQueryVariables>;
export function refetchPairTradesQuery(variables?: PairTradesQueryVariables) {
  return { query: PairTradesDocument, variables: variables };
}
export const TransactionsDocument = gql`
  query transactions(
    $first: Int
    $orderBy: Transaction_orderBy
    $orderDirection: OrderDirection
    $where: Transaction_filter
  ) {
    transactions(first: $first, orderBy: $orderBy, orderDirection: $orderDirection, where: $where) {
      id
      internalID
      block {
        id
        blockHash
        timestamp
        txHash
      }
      data
      ...OrderbookTradeFragment
      ...DepositFragment
      ...WithdrawalFragment
      ...TransferFragment
      ...AccountUpdateFragment
      ...SignatureVerificationFragment
      ...BatchSpotTradeFragment
    }
  }
  ${OrderbookTradeFragmentFragmentDoc}
  ${DepositFragmentFragmentDoc}
  ${WithdrawalFragmentFragmentDoc}
  ${TransferFragmentFragmentDoc}
  ${AccountUpdateFragmentFragmentDoc}
  ${SignatureVerificationFragmentFragmentDoc}
  ${BatchSpotTradeFragmentFragmentDoc}
`;

/**
 * __useTransactionsQuery__
 *
 * To run a query within a React component, call `useTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      orderBy: // value for 'orderBy'
 *      orderDirection: // value for 'orderDirection'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useTransactionsQuery(
  baseOptions?: Apollo.QueryHookOptions<TransactionsQuery, TransactionsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<TransactionsQuery, TransactionsQueryVariables>(TransactionsDocument, options);
}
export function useTransactionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<TransactionsQuery, TransactionsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<TransactionsQuery, TransactionsQueryVariables>(TransactionsDocument, options);
}
export type TransactionsQueryHookResult = ReturnType<typeof useTransactionsQuery>;
export type TransactionsLazyQueryHookResult = ReturnType<typeof useTransactionsLazyQuery>;
export type TransactionsQueryResult = Apollo.QueryResult<TransactionsQuery, TransactionsQueryVariables>;
export function refetchTransactionsQuery(variables?: TransactionsQueryVariables) {
  return { query: TransactionsDocument, variables: variables };
}
export const TransactionDocument = gql`
  query transaction($id: ID!) {
    transaction(id: $id) {
      id
      internalID
      block {
        id
        blockHash
        timestamp
        transactionCount
        txHash
      }
      data
      ...OrderbookTradeFragment
      ...DepositFragment
      ...WithdrawalFragment
      ...TransferFragment
      ...AccountUpdateFragment
      ...SignatureVerificationFragment
      ...BatchSpotTradeFragment
    }
  }
  ${OrderbookTradeFragmentFragmentDoc}
  ${DepositFragmentFragmentDoc}
  ${WithdrawalFragmentFragmentDoc}
  ${TransferFragmentFragmentDoc}
  ${AccountUpdateFragmentFragmentDoc}
  ${SignatureVerificationFragmentFragmentDoc}
  ${BatchSpotTradeFragmentFragmentDoc}
`;

/**
 * __useTransactionQuery__
 *
 * To run a query within a React component, call `useTransactionQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useTransactionQuery(baseOptions: Apollo.QueryHookOptions<TransactionQuery, TransactionQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<TransactionQuery, TransactionQueryVariables>(TransactionDocument, options);
}
export function useTransactionLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<TransactionQuery, TransactionQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<TransactionQuery, TransactionQueryVariables>(TransactionDocument, options);
}
export type TransactionQueryHookResult = ReturnType<typeof useTransactionQuery>;
export type TransactionLazyQueryHookResult = ReturnType<typeof useTransactionLazyQuery>;
export type TransactionQueryResult = Apollo.QueryResult<TransactionQuery, TransactionQueryVariables>;
export function refetchTransactionQuery(variables: TransactionQueryVariables) {
  return { query: TransactionDocument, variables: variables };
}
export const PendingTransactionsDocument = gql`
  query pendingTransactions(
    $transferWhere: Transfer_filter
    $withdrawalWhere: Withdrawal_filter
    $orderBookTradeWhere: OrderbookTrade_filter
    $accountUpdateWhere: AccountUpdate_filter
  ) {
    transfers(where: $transferWhere) {
      id
    }
    withdrawals(where: $withdrawalWhere) {
      id
    }
    orderbookTrades(where: $orderBookTradeWhere) {
      id
    }
    accountUpdates(where: $accountUpdateWhere) {
      id
    }
  }
`;

/**
 * __usePendingTransactionsQuery__
 *
 * To run a query within a React component, call `usePendingTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePendingTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePendingTransactionsQuery({
 *   variables: {
 *      transferWhere: // value for 'transferWhere'
 *      withdrawalWhere: // value for 'withdrawalWhere'
 *      orderBookTradeWhere: // value for 'orderBookTradeWhere'
 *      accountUpdateWhere: // value for 'accountUpdateWhere'
 *   },
 * });
 */
export function usePendingTransactionsQuery(
  baseOptions?: Apollo.QueryHookOptions<PendingTransactionsQuery, PendingTransactionsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<PendingTransactionsQuery, PendingTransactionsQueryVariables>(
    PendingTransactionsDocument,
    options
  );
}
export function usePendingTransactionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<PendingTransactionsQuery, PendingTransactionsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<PendingTransactionsQuery, PendingTransactionsQueryVariables>(
    PendingTransactionsDocument,
    options
  );
}
export type PendingTransactionsQueryHookResult = ReturnType<typeof usePendingTransactionsQuery>;
export type PendingTransactionsLazyQueryHookResult = ReturnType<typeof usePendingTransactionsLazyQuery>;
export type PendingTransactionsQueryResult = Apollo.QueryResult<
  PendingTransactionsQuery,
  PendingTransactionsQueryVariables
>;
export function refetchPendingTransactionsQuery(variables?: PendingTransactionsQueryVariables) {
  return { query: PendingTransactionsDocument, variables: variables };
}
